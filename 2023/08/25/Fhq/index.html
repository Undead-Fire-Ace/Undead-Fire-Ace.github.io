<!-- build time:Sat Sep 16 2023 06:16:30 GMT+0800 (中国标准时间) --><!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="桜の風" href="https://undead-fire-ace.github.io/rss.xml"><link rel="alternate" type="application/atom+xml" title="桜の風" href="https://undead-fire-ace.github.io/atom.xml"><link rel="alternate" type="application/json" title="桜の風" href="https://undead-fire-ace.github.io/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><meta name="keywords" content="数据结构,笔记,平衡树"><link rel="canonical" href="https://undead-fire-ace.github.io/2023/08/25/Fhq/"><title>平衡树全家桶 | Yume Shoka = 桜の風</title><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css"><meta name="generator" content="Hexo 6.3.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">平衡树全家桶</h1><div class="meta"><span class="item" title="创建时间：2023-08-25 21:26:13"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2023-08-25T21:26:13+08:00">2023-08-25</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">本文字数</span> <span>28k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">阅读时长</span> <span>25 分钟</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">Yume Shoka</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://gitcode.net/Rabilista/picture/-/raw/master/pic/78.jpg"></li><li class="item" data-background-image="https://gitcode.net/Rabilista/picture/-/raw/master/pic/39.jpeg"></li><li class="item" data-background-image="https://gitcode.net/Rabilista/picture/-/raw/master/pic/61.jpg"></li><li class="item" data-background-image="https://gitcode.net/Rabilista/picture/-/raw/master/pic/83.jpg"></li><li class="item" data-background-image="https://gitcode.net/Rabilista/picture/-/raw/master/pic/16.jpg"></li><li class="item" data-background-image="https://gitcode.net/Rabilista/picture/-/raw/master/pic/62.jpg"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://undead-fire-ace.github.io/2023/08/25/Fhq/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="Tokai Teio"><meta itemprop="description" content=", "></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="桜の風"></span><div class="body md" itemprop="articleBody"><p>平衡树的种类很多，每种的平衡树的功能和效率也不尽相同，平时主要用的平衡树应该就是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>r</mi><mi>e</mi><mi>a</mi><mi>p</mi></mrow><annotation encoding="application/x-tex">treap</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.80952em;vertical-align:-.19444em"></span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:.02778em">r</span><span class="mord mathnormal">e</span><span class="mord mathnormal">a</span><span class="mord mathnormal">p</span></span></span></span> 类的， <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>p</mi><mi>l</mi><mi>a</mi><mi>y</mi></mrow><annotation encoding="application/x-tex">splay</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.8888799999999999em;vertical-align:-.19444em"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">p</span><span class="mord mathnormal" style="margin-right:.01968em">l</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:.03588em">y</span></span></span></span> ，再带上替罪羊和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mi>b</mi><mi mathvariant="normal">_</mi><mi>d</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">pb\_ds</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.00444em;vertical-align:-.31em"></span><span class="mord mathnormal">p</span><span class="mord mathnormal">b</span><span class="mord" style="margin-right:.02778em">_</span><span class="mord mathnormal">d</span><span class="mord mathnormal">s</span></span></span></span> 也就差不多了，当然还有使用简便的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>e</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">set</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.61508em;vertical-align:0"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">e</span><span class="mord mathnormal">t</span></span></span></span> （底层实现是红黑树，非常的快）。对于每种平衡树，他们都需要维护自身的平衡来保证复杂度。</p><h1 id="treap族rainbow"><a class="markdownIt-Anchor" href="#treap族rainbow"></a> [treap族]{.rainbow}</h1><p>首先我们先看 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>r</mi><mi>e</mi><mi>a</mi><mi>p</mi></mrow><annotation encoding="application/x-tex">treap</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.80952em;vertical-align:-.19444em"></span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:.02778em">r</span><span class="mord mathnormal">e</span><span class="mord mathnormal">a</span><span class="mord mathnormal">p</span></span></span></span> 类的。</p><h2 id="有旋treap"><a class="markdownIt-Anchor" href="#有旋treap"></a> 有旋treap</h2><h3 id="维护平衡的方式"><a class="markdownIt-Anchor" href="#维护平衡的方式"></a> 维护平衡的方式</h3><p>根据他的名字我们就知道他是通过旋转来维护平衡的，旋转分成左旋和右旋，同时为了防止特殊构造，我们普遍在写平衡树的时候，每个节点的键值是随机生成的。</p><h3 id="旋转"><a class="markdownIt-Anchor" href="#旋转"></a> 旋转</h3><p>我们旋转的目的其实就是希望不改变树本身的结构，只改变每一层深度的节点的数量，以此来保证树高，那么我们的旋转分为左旋和右旋。左旋其实就是将某个点的右儿子给变成整棵树的根。右旋同理。</p><p>代码实现如下</p><pre class="highlight"><code class="cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">lrotate</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp;k)</span> 
</span>&#123;
    <span class="hljs-type">int</span> t = r[k];
    r[k] = l[t];   <span class="hljs-comment">//将儿子的左子树接到父亲的右子树上（因为我们是按照权值维护的平衡树）</span>
    l[t] = k;    <span class="hljs-comment">//将父亲设为左儿子</span>
    size_[t] = size_[k];    <span class="hljs-comment">//我们让右儿子继承之前为根的父亲的siz</span>
    <span class="hljs-built_in">pushup</span>(k);   <span class="hljs-comment">//更新siz</span>
    k = t;
&#125;
</code></pre><h3 id="插入"><a class="markdownIt-Anchor" href="#插入"></a> 插入</h3><p>插入操作比较的常规，就直接按照权值递归的左右子树，然后插入完成后，如果不满足堆的性质就通过旋转来维护即可</p><p>代码实现如下</p><pre class="highlight"><code class="cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp;k, <span class="hljs-type">int</span> x)</span> 
</span>&#123;
    <span class="hljs-keyword">if</span> (!k) 
    &#123;
        sz++;
        k = sz;
        size_[k] = w[k] = <span class="hljs-number">1</span>;
        val[k] = x, rnd[k] = <span class="hljs-built_in">rand</span>();
      <span class="hljs-keyword">return</span>;
    &#125;

    size_[k]++;
    <span class="hljs-keyword">if</span> (val[k] == x) 
        w[k]++;
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (val[k] &lt; x) 
    &#123;
        <span class="hljs-built_in">insert</span>(r[k], x);
        <span class="hljs-keyword">if</span> (rnd[r[k]] &lt; rnd[k]) <span class="hljs-built_in">lrotate</span>(k);  <span class="hljs-comment">//插入后不满足堆的性质就旋转</span>
    &#125; 
    <span class="hljs-keyword">else</span> 
    &#123;
        <span class="hljs-built_in">insert</span>(l[k], x);
        <span class="hljs-keyword">if</span> (rnd[l[k]] &lt; rnd[k]) <span class="hljs-built_in">rrotate</span>(k);
    &#125;
&#125;
</code></pre><h3 id="删除"><a class="markdownIt-Anchor" href="#删除"></a> 删除</h3><p>删除比插入要稍微复杂一些，有因为删除后涉及到儿子的更换问题，所有我们删去儿子的时候需要判断我们应该让谁当删去的点的父亲的哪个儿子，其实就是一个分类讨论。按照权值维护好结构后，还要通过旋转维护堆的性质。</p><p>代码实现如下</p><pre class="highlight"><code class="cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">del</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp;k, <span class="hljs-type">int</span> x)</span>
</span>&#123;
    <span class="hljs-keyword">if</span> (!k)
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">if</span> (val[k] == x)
    &#123;
        <span class="hljs-keyword">if</span> (w[k] &gt; <span class="hljs-number">1</span>)
        &#123;
            w[k]--;
            size_[k]--;
            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        &#125;
        <span class="hljs-keyword">if</span> (l[k] == <span class="hljs-number">0</span> || r[k] == <span class="hljs-number">0</span>)
        &#123;
            k = l[k] + r[k];
            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        &#125;
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (rnd[l[k]] &lt; rnd[r[k]])
        &#123;
            <span class="hljs-built_in">rrotate</span>(k);
            <span class="hljs-keyword">return</span> <span class="hljs-built_in">del</span>(k, x);
        &#125;
        <span class="hljs-keyword">else</span>
        &#123;
            <span class="hljs-built_in">lrotate</span>(k);
            <span class="hljs-keyword">return</span> <span class="hljs-built_in">del</span>(k, x);
        &#125;
    &#125;
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (val[k] &lt; x)
    &#123;
        <span class="hljs-type">bool</span> succ = <span class="hljs-built_in">del</span>(r[k], x);
        <span class="hljs-keyword">if</span> (succ)
            size_[k]--;
        <span class="hljs-keyword">return</span> succ;
    &#125;
    <span class="hljs-keyword">else</span>
    &#123;
        <span class="hljs-type">bool</span> succ = <span class="hljs-built_in">del</span>(l[k], x);
        <span class="hljs-keyword">if</span> (succ)
            size_[k]--;
        <span class="hljs-keyword">return</span> succ;
    &#125;
&#125;
</code></pre><h3 id="查询"><a class="markdownIt-Anchor" href="#查询"></a> 查询</h3><h4 id="查询排名按值查序"><a class="markdownIt-Anchor" href="#查询排名按值查序"></a> 查询排名（按值查序）</h4><p>查询以 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.69444em;vertical-align:0"></span><span class="mord mathnormal" style="margin-right:.03148em">k</span></span></span></span> 为根的子树中，值 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">x</span></span></span></span> 的排名，直接根据值的关系去递归求解即可</p><p>代码实现如下</p><pre class="highlight"><code class="cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">queryrank</span><span class="hljs-params">(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span> x)</span>
</span>&#123;
    <span class="hljs-keyword">if</span> (!k)
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    <span class="hljs-keyword">if</span> (val[k] == x)
        <span class="hljs-keyword">return</span> size_[l[k]] + <span class="hljs-number">1</span>;
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (x &gt; val[k])   <span class="hljs-comment">//递归右子树，同时加上左子树的贡献</span>
        <span class="hljs-keyword">return</span> size_[l[k]] + w[k] + <span class="hljs-built_in">queryrank</span>(r[k], x);
    <span class="hljs-keyword">else</span>
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">queryrank</span>(l[k], x);
&#125;
</code></pre><h4 id="查询值按序查值"><a class="markdownIt-Anchor" href="#查询值按序查值"></a> 查询值（按序查值）</h4><p>那么这时，我们就不能通过值的关系递归求解，而是根据树的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>i</mi><mi>z</mi></mrow><annotation encoding="application/x-tex">siz</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.65952em;vertical-align:0"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:.04398em">z</span></span></span></span> 来递归，代码大体一样，但是要注意递归到右子树时要减去左子树的贡献，因为左子树中已经占据了那么多的排名</p><p>代码实现如下</p><pre class="highlight"><code class="cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">querynum</span><span class="hljs-params">(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span> x)</span>
</span>&#123;
    <span class="hljs-keyword">if</span> (!k)
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    <span class="hljs-keyword">if</span> (x &lt;= size_[l[k]])
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">querynum</span>(l[k], x);
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (x &gt; size_[l[k]] + w[k])
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">querynum</span>(r[k], x - size_[l[k]] - w[k]);
    <span class="hljs-keyword">else</span>
        <span class="hljs-keyword">return</span> val[k];
&#125;
</code></pre><h4 id="求前驱第一个比它小的值"><a class="markdownIt-Anchor" href="#求前驱第一个比它小的值"></a> 求前驱（第一个比它小的值）</h4><p>根据定义我们就直接找，当前点比这个值小就去找右子树，如果右子树中的值大于该值，那么前驱即为当前点，递归求解即可</p><p>代码实现如下</p><pre class="highlight"><code class="cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">querypre</span><span class="hljs-params">(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span> x)</span>
</span>&#123;
    <span class="hljs-keyword">if</span> (!k)
        <span class="hljs-keyword">return</span>;
    <span class="hljs-keyword">if</span> (val[k] &lt; x)
        ans = k, <span class="hljs-built_in">querypre</span>(r[k], x);
    <span class="hljs-keyword">else</span>
        <span class="hljs-built_in">querypre</span>(l[k], x);
&#125;
</code></pre><h4 id="求后继第一个比它大的值"><a class="markdownIt-Anchor" href="#求后继第一个比它大的值"></a> 求后继（第一个比它大的值）</h4><p>同理，就直接放代码了</p><pre class="highlight"><code class="cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">querysub</span><span class="hljs-params">(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span> x)</span>
</span>&#123;
    <span class="hljs-keyword">if</span> (!k)
        <span class="hljs-keyword">return</span>;
    <span class="hljs-keyword">if</span> (val[k] &gt; x)
        ans = k, <span class="hljs-built_in">querysub</span>(l[k], x);
    <span class="hljs-keyword">else</span>
        <span class="hljs-built_in">querysub</span>(r[k], x);
&#125;
</code></pre><p>至此为止无旋 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>r</mi><mi>e</mi><mi>a</mi><mi>p</mi></mrow><annotation encoding="application/x-tex">treap</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.80952em;vertical-align:-.19444em"></span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:.02778em">r</span><span class="mord mathnormal">e</span><span class="mord mathnormal">a</span><span class="mord mathnormal">p</span></span></span></span> 就结束了，功能还是非常全的，常数也不是很大。</p><h2 id="无旋treap-fhq-treap-rainbow"><a class="markdownIt-Anchor" href="#无旋treap-fhq-treap-rainbow"></a> [无旋treap (Fhq treap) !!!]{.rainbow}</h2><p>这种平衡树是我最喜欢的，他的思路更好理解，常数也是非常的优秀，而且核心操作少，但是仅仅通过两个核心操作就可以实现许多功能。</p><h3 id="维护平衡的方式-2"><a class="markdownIt-Anchor" href="#维护平衡的方式-2"></a> 维护平衡的方式</h3><p>既然他都叫无旋 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>r</mi><mi>e</mi><mi>a</mi><mi>p</mi></mrow><annotation encoding="application/x-tex">treap</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.80952em;vertical-align:-.19444em"></span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:.02778em">r</span><span class="mord mathnormal">e</span><span class="mord mathnormal">a</span><span class="mord mathnormal">p</span></span></span></span> 了，肯定不是通过旋转维护的平衡，而是通过分裂和合并来维护，那么这也就为他可持久化埋下了伏笔。</p><h3 id="分裂splitrainbow"><a class="markdownIt-Anchor" href="#分裂splitrainbow"></a> [分裂(Split)]{.rainbow}</h3><h4 id="按照值的大小进行分裂rainbow"><a class="markdownIt-Anchor" href="#按照值的大小进行分裂rainbow"></a> [按照值的大小进行分裂]{.rainbow}</h4><p>我们传入分裂依据的值 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi><mi>a</mi><mi>l</mi></mrow><annotation encoding="application/x-tex">val</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.69444em;vertical-align:0"></span><span class="mord mathnormal" style="margin-right:.03588em">v</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:.01968em">l</span></span></span></span> ，那么我们在执行完分裂的操作的时候是会得到两棵树，一颗树的所有值都小于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi><mi>a</mi><mi>l</mi></mrow><annotation encoding="application/x-tex">val</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.69444em;vertical-align:0"></span><span class="mord mathnormal" style="margin-right:.03588em">v</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:.01968em">l</span></span></span></span> ，另外一棵全都大于等于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi><mi>a</mi><mi>l</mi></mrow><annotation encoding="application/x-tex">val</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.69444em;vertical-align:0"></span><span class="mord mathnormal" style="margin-right:.03588em">v</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:.01968em">l</span></span></span></span> 。</p><p>代码实现如下</p><pre class="highlight"><code class="cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">split_v</span><span class="hljs-params">(<span class="hljs-type">int</span> pos, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> &amp;l, <span class="hljs-type">int</span> &amp;r)</span>  <span class="hljs-comment">//l 和 r是我们分裂后得到的两个根</span>
</span>&#123;
    <span class="hljs-keyword">if</span> (!pos)
    &#123;
        l = r = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">return</span> ;
    &#125;
    <span class="hljs-keyword">else</span> 
    &#123;
        <span class="hljs-keyword">if</span> (tr[pos].val &lt;= k)
            l = pos, <span class="hljs-built_in">split_v</span>(tr[pos].r, k, tr[pos].r, r);
        <span class="hljs-keyword">else</span>
            r = pos, <span class="hljs-built_in">split_v</span>(tr[pos].l, k, l, tr[pos].l);
    &#125;
    <span class="hljs-built_in">update</span>(pos);
&#125;
</code></pre><h4 id="按照子树的大小进行分裂rainbow"><a class="markdownIt-Anchor" href="#按照子树的大小进行分裂rainbow"></a> [按照子树的大小进行分裂]{.rainbow}</h4><p>我们会得到两棵树（前提是整棵树足够大），然后一棵树是等于我们传入的参数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>i</mi><mi>z</mi></mrow><annotation encoding="application/x-tex">siz</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.65952em;vertical-align:0"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:.04398em">z</span></span></span></span> ，另外一颗大小随意。</p><p>代码实现如下</p><pre class="highlight"><code class="cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">split_s</span><span class="hljs-params">(<span class="hljs-type">int</span> now, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> &amp;x, <span class="hljs-type">int</span> &amp;y)</span>
</span>&#123;
    <span class="hljs-keyword">if</span>(!now)
    &#123;
        x = y = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">return</span>;
    &#125;
    <span class="hljs-keyword">if</span>(tr[tr[now].l].siz + <span class="hljs-number">1</span> &lt;= k)
    &#123;
        x = now;
        <span class="hljs-built_in">split_s</span>(tr[now].r, k - tr[tr[now].l].siz - <span class="hljs-number">1</span>, tr[x].r, y);
        <span class="hljs-built_in">update</span>(x);
    &#125;
    <span class="hljs-keyword">else</span> 
    &#123;
        y = now;
        <span class="hljs-built_in">split_s</span>(tr[now].l, k, y, tr[now].l);
        <span class="hljs-built_in">update</span>(y);
    &#125;
&#125;
</code></pre><h4 id="作用"><a class="markdownIt-Anchor" href="#作用"></a> 作用</h4><p>我们实现了上面两种形式的分裂那么有什么用呢？显然易见按值分裂时用来处理跟值有关的问题，比如求前驱后继啥的，按照子树分裂就是来处理排名啥的，当然这两种形式还有别的功能，这将会在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mi>e</mi><mi>r</mi><mi>g</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">merge</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.625em;vertical-align:-.19444em"></span><span class="mord mathnormal">m</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:.02778em">r</span><span class="mord mathnormal" style="margin-right:.03588em">g</span><span class="mord mathnormal">e</span></span></span></span> 之后一起说。</p><h3 id="合并mergerainbow"><a class="markdownIt-Anchor" href="#合并mergerainbow"></a> [合并(merge)]{.rainbow}</h3><p>合并就是将两棵树合并为一棵树，我们依旧要考虑树的平衡问题，但是我们会发现我们的树合并之后时保证平衡的，那么将两棵树合并的时候这两棵树也一定时平衡的，所以直接按照根节点的值的大小和堆的性质合并即可。</p><p>代码实现如下</p><pre class="highlight"><code class="cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span>   <span class="hljs-comment">//这是返回根节点</span>
</span>&#123;
    <span class="hljs-keyword">if</span>(!x || !y)  
        <span class="hljs-keyword">return</span> x | y;
    <span class="hljs-keyword">if</span>(tr[x].key &gt; tr[y].key) 
    &#123;
        tr[x].r = <span class="hljs-built_in">merge</span>(tr[x].r, y);
        <span class="hljs-built_in">update</span>(x);
        <span class="hljs-keyword">return</span> x;
    &#125;

    tr[y].l = <span class="hljs-built_in">merge</span>(x, tr[y].l);
    <span class="hljs-built_in">update</span>(y);
    <span class="hljs-keyword">return</span> y;
&#125;
</code></pre><h3 id="功能"><a class="markdownIt-Anchor" href="#功能"></a> 功能</h3><p>我们现在具备了合并和分裂两个核心操作，我们就可以搞更多的事情了。</p><h4 id="插入rainbow"><a class="markdownIt-Anchor" href="#插入rainbow"></a> [插入]{.rainbow}</h4><p>插入操作也是可以分成两种类型的，一种是直接插入某个值，一个是在某个位置插入值，那么我们就直接分别按照对应形式分裂，最后再合并即可</p><p>代码实现如下</p><pre class="highlight"><code class="cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert_k</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span>   <span class="hljs-comment">//插入一个值为key的数</span>
</span>&#123;
    <span class="hljs-type">int</span> x, y;
    <span class="hljs-built_in">split_v</span>(rt, key, x, y);
    rt = <span class="hljs-built_in">merge</span>(<span class="hljs-built_in">merge</span>(x, <span class="hljs-built_in">new_node</span>(key)), y);
&#125;

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">inset_p</span><span class="hljs-params">(<span class="hljs-type">int</span> pos, <span class="hljs-type">int</span> key)</span>   <span class="hljs-comment">//在pos后插入一个数</span>
</span>&#123;
    <span class="hljs-type">int</span> x, y;
    <span class="hljs-built_in">split_s</span>(rt, pos, x, y);
    rt = <span class="hljs-built_in">merge</span>(<span class="hljs-built_in">merge</span>(x, <span class="hljs-built_in">new_node</span>(key)), y);
&#125;
</code></pre><h4 id="删除rainbow"><a class="markdownIt-Anchor" href="#删除rainbow"></a> [删除]{.rainbow}</h4><p>有了插入当然还有删除操作，也是分两种，一个是直接删除某个值，一个是删除某个位置的值，也是根插入一个道理,当然也可以删除一个区间。</p><p>代码实现如下</p><pre class="highlight"><code class="cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span>   <span class="hljs-comment">//删除一个区间</span>
</span>&#123;
    <span class="hljs-type">int</span> x, y, z;
    <span class="hljs-built_in">split_s</span>(rt, l - <span class="hljs-number">1</span>, x, y), <span class="hljs-built_in">split_s</span>(y, r - l + <span class="hljs-number">1</span>, y, z);
    rt = <span class="hljs-built_in">merge</span>(x, z);
&#125;

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">del</span><span class="hljs-params">(<span class="hljs-type">int</span> k)</span>   <span class="hljs-comment">//删去一个数</span>
</span>&#123;
    <span class="hljs-type">int</span> x, y, z;
    <span class="hljs-built_in">split_v</span>(rt, k, x, y), <span class="hljs-built_in">split_v</span>(y, k, y, z);
    <span class="hljs-keyword">if</span>(y)
        y = <span class="hljs-built_in">merge</span>(tr[y].l, tr[y].r);
    rt = <span class="hljs-built_in">merge</span>(<span class="hljs-built_in">merge</span>(x, y), z);
&#125;

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">remove_a</span><span class="hljs-params">(<span class="hljs-type">int</span> k)</span>   <span class="hljs-comment">//删去所有值为k的数</span>
</span>&#123;
    <span class="hljs-type">int</span> x, y, z;
    <span class="hljs-built_in">split_v</span>(rt, k - <span class="hljs-number">1</span>, x, y), <span class="hljs-built_in">split_v</span>(y, k, y, z);
    <span class="hljs-built_in">merge</span>(x, z);
&#125;
</code></pre><h4 id="其他"><a class="markdownIt-Anchor" href="#其他"></a> 其他</h4><p>还有各种查询，就按照需要什么区间就分裂啥区间，最后再对应操作即可，由于我们可以将一个区间分裂出来，那么我们做区间操作也就更加的方便。</p><pre class="highlight"><code class="cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_k</span><span class="hljs-params">(<span class="hljs-type">int</span> k)</span>   <span class="hljs-comment">//按值查序</span>
</span>&#123;
    <span class="hljs-type">int</span> dl, dr;
    <span class="hljs-built_in">split_v</span>(rt, k, dl, dr);
    <span class="hljs-type">int</span> rank = dl.siz + <span class="hljs-number">1</span>;
    rt = <span class="hljs-built_in">merge</span>(dl, dr);
    <span class="hljs-keyword">return</span> rank;
&#125;

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_v</span><span class="hljs-params">(<span class="hljs-type">int</span> k)</span>  <span class="hljs-comment">//按序查值</span>
</span>&#123;
    <span class="hljs-type">int</span> p = root;
    <span class="hljs-keyword">while</span>(p)
    &#123;
        <span class="hljs-keyword">if</span>(tr[tr[p].l].siz + <span class="hljs-number">1</span> == k)
            <span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(tr[tr[p].l].siz &gt;= k)
            p = tr[p].l;
        <span class="hljs-keyword">else</span> 
        &#123;
            k -= tr[tr[p].l].siz + <span class="hljs-number">1</span>;
            p = tr[p].r;
        &#125;
    &#125;
    <span class="hljs-keyword">return</span> tr[p].val
&#125;
</code></pre><p>至此我们的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>r</mi><mi>e</mi><mi>a</mi><mi>p</mi></mrow><annotation encoding="application/x-tex">treap</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.80952em;vertical-align:-.19444em"></span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:.02778em">r</span><span class="mord mathnormal">e</span><span class="mord mathnormal">a</span><span class="mord mathnormal">p</span></span></span></span> 家族就基本上讲完了</p><h1 id="替罪羊树"><a class="markdownIt-Anchor" href="#替罪羊树"></a> 替罪羊树</h1><p>一种比较暴力的平衡树，为啥暴力呢？因为他的思想是不平衡就重构，但是这个不平衡是有忍耐度的，意思就是我们会设定一个系数，如果某个子树的系数超过设定的系数，就将这个子树给拆了重构，以此来维护平衡</p><p>我们先构建一个权值平衡树，以及计算根节点的信息（将权值相同的点直接合并到一个点上）</p><p>代码实现如下</p><pre class="highlight"><code class="cpp"><span class="hljs-type">int</span> tot,             <span class="hljs-comment">// 树中元素总数</span>
    rt,              <span class="hljs-comment">// 根节点，初值为 0 代表空树</span>
    w[N],            <span class="hljs-comment">// 点中的数据 / 权值</span>
    l[N], r[N],      <span class="hljs-comment">// 左右子树</span>
    cnt[N],          <span class="hljs-comment">// 本数据出现次数（为 0 代表已删除）</span>
    s[N],            <span class="hljs-comment">// 以本节点为根的子树大小（每个节点记 1 次）</span>
    sz[N],           <span class="hljs-comment">// 以本节点为根的子树大小（每个节点记 cnt[k] 次）</span>
    del[N];          <span class="hljs-comment">// 不计已删除节点的子树大小（每个节点记 1 次）</span>

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Cal</span><span class="hljs-params">(<span class="hljs-type">int</span> k)</span>   <span class="hljs-comment">// 重新计算以 k 为根的子树大小</span>
</span>&#123;
    s[k] = s[l[k]] + s[r[k]] + <span class="hljs-number">1</span>;
    sz[k] = sz[l[k]] + sz[r[k]] + cnt[k];
    del[k] = del[l[k]] + del[r[k]] + (cnt[k] != <span class="hljs-number">0</span>);
&#125;
</code></pre><h2 id="重构"><a class="markdownIt-Anchor" href="#重构"></a> 重构</h2><p>首先我们要设定一个系数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>l</mi><mi>p</mi><mi>h</mi><mi>a</mi></mrow><annotation encoding="application/x-tex">alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.8888799999999999em;vertical-align:-.19444em"></span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:.01968em">l</span><span class="mord mathnormal">p</span><span class="mord mathnormal">h</span><span class="mord mathnormal">a</span></span></span></span> ，一般取 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0.7</mn></mrow><annotation encoding="application/x-tex">0.7</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">0</span><span class="mord">.</span><span class="mord">7</span></span></span></span> 或者 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0.8</mn></mrow><annotation encoding="application/x-tex">0.8</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">0</span><span class="mord">.</span><span class="mord">8</span></span></span></span>。如果一个点的子节点占比大于设定的系数就直接重构。同时我们删除的时候也不全删，打个标记，但是我们会发现，如果我们删除的结点非常多的时候重构的复杂度也是非常高的，所以就删除的节点占比超过系数也重构.</p><p>代码实现如下</p><pre class="highlight"><code class="cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">can_rebuild</span><span class="hljs-params">(<span class="hljs-type">int</span> k)</span>
</span>&#123;
    <span class="hljs-keyword">return</span> wn[k] &amp;&amp; (alpha * s[k] &lt;= (<span class="hljs-type">double</span>)<span class="hljs-built_in">max</span>(s[l[k]], s[r[k]]) || (<span class="hljs-type">double</span>)del[k] &lt;= alpha * s[k]);
&#125;
</code></pre><p>然后就是具体的怎么重构了，分为两步，我们首先中序遍历一遍，然后再二分重建。</p><pre class="highlight"><code class="cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Rbu_dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp;top, <span class="hljs-type">int</span> k)</span>
</span>&#123;
    <span class="hljs-comment">// 中序遍历展开以 k 节点为根子树</span>
    <span class="hljs-keyword">if</span> (!k)
        <span class="hljs-keyword">return</span>;
    <span class="hljs-built_in">Rbu_dfs</span>(top, l[k]);
    <span class="hljs-keyword">if</span> (wn[k])
        stk[top++] = k;
    <span class="hljs-comment">// 若当前节点已删除则不保留</span>
    <span class="hljs-built_in">Rbu_dfs</span>(top, r[k]);
&#125;

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Rbu_Build</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span>   <span class="hljs-comment">//重建</span>
</span>&#123;
    <span class="hljs-comment">// 将 stk[] 数组内 [l, r) 区间重建成树，返回根节点</span>
    <span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>; <span class="hljs-comment">// 选取中间为根使其平衡</span>
    <span class="hljs-keyword">if</span> (l &gt;= r)
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    lc[stk[mid]] = <span class="hljs-built_in">Rbu_Build</span>(l, mid);
    rc[stk[mid]] = <span class="hljs-built_in">Rbu_Build</span>(mid + <span class="hljs-number">1</span>, r); <span class="hljs-comment">// 建左右子树</span>
    <span class="hljs-built_in">Calc</span>(stk[mid]);
    <span class="hljs-keyword">return</span> stk[mid];
&#125;

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Rbu</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp;k)</span>
</span>&#123;
    <span class="hljs-comment">// 重构节点 k 的全过程</span>
    <span class="hljs-type">int</span> top = <span class="hljs-number">0</span>;
    <span class="hljs-built_in">Rbu_dfs</span>(top, k);
    k = <span class="hljs-built_in">Rbu_Build</span>(<span class="hljs-number">0</span>, top);
&#125;
</code></pre><h2 id="插入-删除"><a class="markdownIt-Anchor" href="#插入-删除"></a> 插入 &amp; 删除</h2><p>跟普通的线段树同理，即到了空节点直接新建，然后再 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mi>n</mi><mi>t</mi><mo>+</mo><mo>+</mo></mrow><annotation encoding="application/x-tex">cnt++</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.69841em;vertical-align:-.08333em"></span><span class="mord mathnormal">c</span><span class="mord mathnormal">n</span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:.66666em;vertical-align:-.08333em"></span><span class="mord">+</span></span></span></span> 就行。删除同理，区别是到了空节点不操作，然后 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mi>n</mi><mi>t</mi><mo>−</mo><mo>−</mo></mrow><annotation encoding="application/x-tex">cnt--</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.69841em;vertical-align:-.08333em"></span><span class="mord mathnormal">c</span><span class="mord mathnormal">n</span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:.66666em;vertical-align:-.08333em"></span><span class="mord">−</span></span></span></span> ，插入或者是删除后，如果有需要重构的点就重构</p><p>代码实现如下</p><pre class="highlight"><code class="cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp;k, <span class="hljs-type">int</span> p)</span>
</span>&#123;
    <span class="hljs-comment">// 在以 k 为根的子树内添加权值为 p 节点</span>
    <span class="hljs-keyword">if</span> (!k)
    &#123;
        k = ++cnt;
        <span class="hljs-keyword">if</span> (!rt)
            rt = <span class="hljs-number">1</span>;
        w[k] = p;
        l[k] = rc[k] = <span class="hljs-number">0</span>;
        cnt[k] = s[k] = sz[k] = sd[k] = <span class="hljs-number">1</span>;
    &#125;
    <span class="hljs-keyword">else</span>
    &#123;
        <span class="hljs-keyword">if</span> (w[k] == p)
            cnt[k]++;
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (w[k] &lt; p)
            <span class="hljs-built_in">insert</span>(rc[k], p);
        <span class="hljs-keyword">else</span>
            <span class="hljs-built_in">insert</span>(l[k], p);
        <span class="hljs-built_in">Calc</span>(k);
        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">can_rebuild</span>(k))
            <span class="hljs-built_in">Rbu</span>(k);
    &#125;
&#125;

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">del</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp;k, <span class="hljs-type">int</span> p)</span>
</span>&#123;
    <span class="hljs-comment">// 从以 k 为根子树移除权值为 p 节点</span>
    <span class="hljs-keyword">if</span> (!k)
        <span class="hljs-keyword">return</span>;
    <span class="hljs-keyword">else</span>
    &#123;
        <span class="hljs-keyword">if</span> (w[k] == p)
        &#123;
            <span class="hljs-keyword">if</span> (cnt[k])
                cnt[k]--;
        &#125;
        <span class="hljs-keyword">else</span>
        &#123;
            <span class="hljs-keyword">if</span> (w[k] &lt; p)
                <span class="hljs-built_in">del</span>(rc[k], p);
            <span class="hljs-keyword">else</span>
                <span class="hljs-built_in">del</span>(l[k], p);
        &#125;
        <span class="hljs-built_in">Calc</span>(k);
        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">can_rebuild</span>(k))
            <span class="hljs-built_in">Rbu</span>(k);
    &#125;
&#125;
</code></pre><h2 id="其他-2"><a class="markdownIt-Anchor" href="#其他-2"></a> 其他</h2><p>求前驱后继，排名，值之类的操作跟普通平衡树一样，这里就直接放代码了</p><pre class="highlight"><code class="cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Upper_bound</span><span class="hljs-params">(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span> p)</span>
</span>&#123;
    <span class="hljs-comment">// 在以 k 为根子树中，大于 p 的最小数的名次</span>
    <span class="hljs-keyword">if</span> (!k)
        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (w[k] == p &amp;&amp; cnt[k])
        <span class="hljs-keyword">return</span> sz[l[k]] + <span class="hljs-number">1</span> + cnt[k];
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p &lt; w[k])
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Upper_bound</span>(l[k], p);
    <span class="hljs-keyword">else</span>
        <span class="hljs-keyword">return</span> sz[l[k]] + cnt[k] + <span class="hljs-built_in">Upper_bound</span>(r[k], p);
&#125;


<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Lower_bound</span><span class="hljs-params">(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span> p)</span>    <span class="hljs-comment">//查某个数的排名直接 lower_boun(rt, x) + 1即可</span>
</span>&#123;
  <span class="hljs-keyword">if</span> (!k)
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (w[k] == p &amp;&amp; cnt[k])
    <span class="hljs-keyword">return</span> sz[l[k]];
  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (w[k] &lt; p)
    <span class="hljs-keyword">return</span> sz[l[k]] + cnt[k] + <span class="hljs-built_in">Lower_bound</span>(r[k], p);
  <span class="hljs-keyword">else</span>
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Lower_bound</span>(lc[k], p);
&#125;

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query_w_by_pos</span><span class="hljs-params">(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span> p)</span>
</span>&#123;
    <span class="hljs-comment">// 以 k 为根的子树中，名次为 p 的权值</span>
    <span class="hljs-keyword">if</span> (!k)
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sz[l[k]] &lt; p &amp;&amp; p &lt;= sz[l[k]] + cnt[k])
        <span class="hljs-keyword">return</span> w[k];
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sz[l[k]] + cnt[k] &lt; p)
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">query_w_by_pos</span>(rc[k], p - sz[l[k]] - cnt[k]);
    <span class="hljs-keyword">else</span>
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">query_w_by_pos</span>(l[k], p);
&#125;
</code></pre><h1 id="splay"><a class="markdownIt-Anchor" href="#splay"></a> Splay</h1><p>最后就是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>p</mi><mi>l</mi><mi>a</mi><mi>y</mi></mrow><annotation encoding="application/x-tex">splay</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.8888799999999999em;vertical-align:-.19444em"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">p</span><span class="mord mathnormal" style="margin-right:.01968em">l</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:.03588em">y</span></span></span></span> 了，为啥把他放最后？因为个人觉得不是很好理解，而且他还有一个非常重要的应用就是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mi>C</mi><mi>T</mi></mrow><annotation encoding="application/x-tex">LCT</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.68333em;vertical-align:0"></span><span class="mord mathnormal">L</span><span class="mord mathnormal" style="margin-right:.07153em">C</span><span class="mord mathnormal" style="margin-right:.13889em">T</span></span></span></span> ，也就是用来解决动态树问题，可能占的篇幅比较大，所以就放在最后。我们先看一些 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>p</mi><mi>l</mi><mi>a</mi><mi>y</mi></mrow><annotation encoding="application/x-tex">splay</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.8888799999999999em;vertical-align:-.19444em"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">p</span><span class="mord mathnormal" style="margin-right:.01968em">l</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:.03588em">y</span></span></span></span> 的基本操作。</p><h2 id="rotate"><a class="markdownIt-Anchor" href="#rotate"></a> Rotate</h2><p>这个操作就是将一个节点的深度变低一层，原来我们是需要左旋和右旋，但是经过不断的迭代，左旋和右旋合并成了一个操作，就是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mi>o</mi><mi>t</mi><mi>a</mi><mi>t</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">Rotate</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.68333em;vertical-align:0"></span><span class="mord mathnormal" style="margin-right:.00773em">R</span><span class="mord mathnormal">o</span><span class="mord mathnormal">t</span><span class="mord mathnormal">a</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span></span></span></span> 。</p><p>代码实现如下</p><pre class="highlight"><code class="cpp"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">rotate</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span>
</span>&#123;
    <span class="hljs-type">int</span> y = tr[x].fa;   <span class="hljs-comment">//取出父节点</span>
    <span class="hljs-type">int</span> z = tr[y].fa; 
    <span class="hljs-type">int</span> k = tr[y].s[<span class="hljs-number">1</span>] == x;     <span class="hljs-comment">//k = 0表示x是y的左儿子；k = 1表示x是y的右儿子</span>

    tr[z].s[tr[z].s[<span class="hljs-number">1</span>] == y] = x, tr[x].fa = z;    <span class="hljs-comment">//将当前点变成z的左儿子或者是右儿子</span>
    tr[y].s[k] = tr[x].s[k ^ <span class="hljs-number">1</span>],tr[tr[x].s[k ^ <span class="hljs-number">1</span>]].fa = y;
    tr[x].s[k ^ <span class="hljs-number">1</span>] = y,tr[y].fa = x;

    <span class="hljs-built_in">pushup</span>(y), <span class="hljs-built_in">pushup</span>(x);
&#125;
</code></pre><h2 id="splay-2"><a class="markdownIt-Anchor" href="#splay-2"></a> Splay</h2><p>将节点旋转到根，我们为什么要将一个节点旋转到根呢？目的有两个，一个是有时操作需要，另外一个就是根据期望来算，我们对一个点操作后，如果需要经常查询和使用一个数，那么把它旋转到根节点，这样下次访问它就只需查一次就找到了。</p><p>代码实现如下</p><pre class="highlight"><code class="cpp"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">splay</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> k)</span>      <span class="hljs-comment">//将点x旋转至点k下面   splay(x,0):将x旋转到根</span>
</span>&#123;
    <span class="hljs-keyword">while</span>(tr[x].p != k)
    &#123;
        <span class="hljs-type">int</span> y = tr[x].p, z = tr[y].p;
        <span class="hljs-keyword">if</span>(z != k)
        &#123;
            <span class="hljs-keyword">if</span>((tr[y].s[<span class="hljs-number">1</span>] == x) ^ (tr[z].s[<span class="hljs-number">1</span>] == y)) <span class="hljs-comment">//如果不是一条链就正常转</span>
                <span class="hljs-built_in">rotate</span>(x);
            <span class="hljs-keyword">else</span> <span class="hljs-built_in">rotate</span>(y);   <span class="hljs-comment">//是一条链我们需要将其链的结构改变</span>
        &#125;    
        <span class="hljs-built_in">rotate</span>(x);
    &#125;

    <span class="hljs-keyword">if</span>(!k) root = x;
&#125;
</code></pre><h2 id="插入-2"><a class="markdownIt-Anchor" href="#插入-2"></a> 插入</h2><p>这个也比较好说，类比 [treap]{.rainbow} ，我们应该能很自然的想到我们可以直接按照权值关系递归插入，实现起来也不难。</p><p>代码实现如下</p><pre class="highlight"><code class="cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Tree</span>
&#123;
    <span class="hljs-type">int</span> s[<span class="hljs-number">2</span>];
    <span class="hljs-type">int</span> fa, v;   <span class="hljs-comment">//fa：父节点  v：编号</span>
    <span class="hljs-type">int</span> siz, cnt;   <span class="hljs-comment">//siz：子树大小  cnt：当前位置的数出现次数</span>

    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-type">int</span> _v,<span class="hljs-type">int</span> _p)</span>   <span class="hljs-comment">//初始化函数</span>
    </span>&#123;
        v = _v,p = _p;
        siz = <span class="hljs-number">1</span>, cnt = <span class="hljs-number">1</span>;
    &#125;
&#125;tr[N];

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> v)</span>
</span>&#123;
    <span class="hljs-type">int</span> u = root,p = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">while</span>(u) 
        p = u,u = tr[u].s[v &gt; tr[u].v];   <span class="hljs-comment">//根据值的关系递归左右子树</span>

    u = ++ idx;
    <span class="hljs-keyword">if</span>(p)
        tr[p].s[v &gt; tr[p].v] = u;
    tr[u].<span class="hljs-built_in">init</span>(v,p);

    <span class="hljs-built_in">splay</span>(u,<span class="hljs-number">0</span>);    <span class="hljs-comment">//记得旋转到根，来保证复杂度</span>
&#125;
</code></pre><h2 id="查询-2"><a class="markdownIt-Anchor" href="#查询-2"></a> 查询</h2><h3 id="按值查序"><a class="markdownIt-Anchor" href="#按值查序"></a> 按值查序</h3><p>其实说了那么多应该能想到，我们直接递归左右区间，递归到右子树的时候再加上左子树的贡献即可</p><pre class="highlight"><code class="cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_k</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span>
</span>&#123;
    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>, pos = rt;
    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)
    &#123;
        <span class="hljs-keyword">if</span>(x &lt; tr[pos].v)
            pos = tr[pos].s[<span class="hljs-number">0</span>];
        <span class="hljs-keyword">else</span> 
        &#123;
            res += tr[pos].siz;
            <span class="hljs-keyword">if</span>(x == tr[pos].v)
            &#123;
                <span class="hljs-built_in">splay</span>(pos);
                <span class="hljs-keyword">return</span> res + <span class="hljs-number">1</span>;
            &#125;
            res += tr[u].cnt
            pos = tr[u].s[<span class="hljs-number">1</span>];
        &#125;
    &#125;
&#125;
</code></pre><h3 id="按序查值"><a class="markdownIt-Anchor" href="#按序查值"></a> 按序查值</h3><p>同理就直接放代码了</p><pre class="highlight"><code class="cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_v</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span>
</span>&#123;
    <span class="hljs-type">int</span> pos = rt;
    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)
    &#123;
        <span class="hljs-keyword">if</span>(tr[pos].s[<span class="hljs-number">0</span>] &amp;&amp; k &lt;= tr[tr[pos].s[<span class="hljs-number">0</span>]].siz)
            pos = tr[u].s[<span class="hljs-number">0</span>];
        <span class="hljs-keyword">else</span> 
        &#123;
            k -= tr[pos].cnt + tr[tr[pos].s[<span class="hljs-number">0</span>]].siz;
            <span class="hljs-keyword">if</span>(k &lt;= <span class="hljs-number">0</span>)
            &#123;
                <span class="hljs-built_in">splay</span>(pos);
                <span class="hljs-keyword">return</span> tr[pos].v;
            &#125;
            pos = tr[pos].v;
        &#125;
    &#125;
&#125;
</code></pre><h1 id="lctrainbow"><a class="markdownIt-Anchor" href="#lctrainbow"></a> [LCT]{.rainbow}</h1><p>终于到了这个大家伙了，这个东西的函数是真的多啊，但是每个函数的实现感觉还是比较好理解的。首先我们对于一个树，我们的剖分方式其实之前是学过两种的，有重链剖分和长链剖分，这里 [LCT]{.rainbow} 的剖分方式就是实链剖分，剖分后，我们得到的树是由若干的实边和虚边的组成的这也就导致它有一些性质。</p><p>+++danger 性质</p><ul><li>对于这棵树每一条实链，我们是通过一颗 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>p</mi><mi>l</mi><mi>a</mi><mi>y</mi></mrow><annotation encoding="application/x-tex">splay</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.8888799999999999em;vertical-align:-.19444em"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">p</span><span class="mord mathnormal" style="margin-right:.01968em">l</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:.03588em">y</span></span></span></span> 维护的， <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>p</mi><mi>l</mi><mi>a</mi><mi>y</mi></mrow><annotation encoding="application/x-tex">splay</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.8888799999999999em;vertical-align:-.19444em"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">p</span><span class="mord mathnormal" style="margin-right:.01968em">l</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:.03588em">y</span></span></span></span> 的中序遍历就是我们所维护的路径</li><li>然后对于每棵 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>p</mi><mi>l</mi><mi>a</mi><mi>y</mi></mrow><annotation encoding="application/x-tex">splay</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.8888799999999999em;vertical-align:-.19444em"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">p</span><span class="mord mathnormal" style="margin-right:.01968em">l</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:.03588em">y</span></span></span></span> ，我们是通过前驱和后继来维护序列，即我们一条实链中的每个点是只一个父亲和最多一个儿子</li><li>对于两个实链，他们是通过虚边来连接的，所以是一个 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>p</mi><mi>l</mi><mi>a</mi><mi>y</mi></mrow><annotation encoding="application/x-tex">splay</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.8888799999999999em;vertical-align:-.19444em"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">p</span><span class="mord mathnormal" style="margin-right:.01968em">l</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:.03588em">y</span></span></span></span> 的根的父亲为另一个 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>p</mi><mi>l</mi><mi>a</mi><mi>y</mi></mrow><annotation encoding="application/x-tex">splay</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.8888799999999999em;vertical-align:-.19444em"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">p</span><span class="mord mathnormal" style="margin-right:.01968em">l</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:.03588em">y</span></span></span></span> 中的一个点，同时对于虚边，是父亲不认儿子，但是儿子认父亲，也就是我们常说的认父不认子<br>+++</li></ul><p>然后就是我们的若干操作了。</p><h2 id="accessrainbow"><a class="markdownIt-Anchor" href="#accessrainbow"></a> [access]{.rainbow}</h2><p>这个 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>c</mi><mi>c</mi><mi>e</mi><mi>s</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">access</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">a</span><span class="mord mathnormal">c</span><span class="mord mathnormal">c</span><span class="mord mathnormal">e</span><span class="mord mathnormal">s</span><span class="mord mathnormal">s</span></span></span></span> 函数的功能就是把从根到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">x</span></span></span></span> 的路径都变成实边，同时 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">x</span></span></span></span> 变成 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>p</mi><mi>l</mi><mi>a</mi><mi>y</mi></mrow><annotation encoding="application/x-tex">splay</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.8888799999999999em;vertical-align:-.19444em"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">p</span><span class="mord mathnormal" style="margin-right:.01968em">l</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:.03588em">y</span></span></span></span> 的根节点。</p><p>代码实现如下</p><pre class="highlight"><code class="cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">access</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span>    <span class="hljs-comment">//把从根到 x 的路径都变成实边，同时 x 变成 splay 的根节点</span>
</span>&#123;
    <span class="hljs-type">int</span> z = x;
    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> y = <span class="hljs-number">0</span> ; x ; y = x, x = tr[x].fa)   <span class="hljs-comment">//一直跳父亲</span>
    &#123;
        <span class="hljs-built_in">splay</span>(x);    <span class="hljs-comment">//我们先将 x 转到根节点</span>
        tr[x].s[<span class="hljs-number">1</span>] = y;    <span class="hljs-comment">//因为按照中序遍历，x是最后一个节点，因此直接让y变成 x 的后继即可</span>
        <span class="hljs-built_in">pushup</span>(x);
    &#125;
    <span class="hljs-built_in">splay</span>(z);
&#125;
</code></pre><h2 id="makeroot"><a class="markdownIt-Anchor" href="#makeroot"></a> makeroot</h2><p>即将 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">x</span></span></span></span> 变成原树的根</p><p>代码实现如下</p><pre class="highlight"><code class="cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushrev</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span>
</span>&#123;
    <span class="hljs-built_in">swap</span>(tr[x].s[<span class="hljs-number">0</span>], tr[x].s[<span class="hljs-number">1</span>]);
    tr[x].rev ^= <span class="hljs-number">1</span>;
&#125;

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">makeroot</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span>
</span>&#123;
    <span class="hljs-built_in">access</span>(x);   <span class="hljs-comment">//建边</span>
    <span class="hljs-built_in">pushrev</span>(x);    <span class="hljs-comment">//然后翻转路径,因为翻转路径实际上是不会影响遍历的</span>
&#125;
</code></pre><h2 id="findroot"><a class="markdownIt-Anchor" href="#findroot"></a> findroot</h2><p>找到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">x</span></span></span></span> 在原树中的根节点，然后将原树的根节点转到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>p</mi><mi>l</mi><mi>a</mi><mi>y</mi></mrow><annotation encoding="application/x-tex">splay</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.8888799999999999em;vertical-align:-.19444em"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">p</span><span class="mord mathnormal" style="margin-right:.01968em">l</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:.03588em">y</span></span></span></span> 的的根节点</p><p>代码实现如下</p><pre class="highlight"><code class="cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findroot</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span>    <span class="hljs-comment">//找到 x 在原树中的根节点，然后将原树的根节点转到splay的的根节点</span>
</span>&#123;
    <span class="hljs-built_in">access</span>(x);
    <span class="hljs-keyword">while</span>(tr[x].s[<span class="hljs-number">0</span>])  <span class="hljs-comment">//建完实边之后，那么他就成为了根节点，此时一直跳前驱就能找到父亲</span>
        <span class="hljs-built_in">pushdown</span>(x), x = tr[x].s[<span class="hljs-number">0</span>];   
    <span class="hljs-built_in">splay</span>(x);
    <span class="hljs-keyword">return</span> x;
&#125;
</code></pre><h2 id="split"><a class="markdownIt-Anchor" href="#split"></a> split</h2><p>这个函数得和 [Fhq]{.rainbow} 中的 [split]{.rainbow} 区分开，这里的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>p</mi><mi>l</mi><mi>i</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">split</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.8888799999999999em;vertical-align:-.19444em"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">p</span><span class="mord mathnormal" style="margin-right:.01968em">l</span><span class="mord mathnormal">i</span><span class="mord mathnormal">t</span></span></span></span> 是给 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">x</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.625em;vertical-align:-.19444em"></span><span class="mord mathnormal" style="margin-right:.03588em">y</span></span></span></span> 之间的点建一条路径，然后根节点为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.625em;vertical-align:-.19444em"></span><span class="mord mathnormal" style="margin-right:.03588em">y</span></span></span></span> 。但是这仅仅是定义，在实际应用上我们通常认为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>p</mi><mi>l</mi><mi>i</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">split</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.8888799999999999em;vertical-align:-.19444em"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">p</span><span class="mord mathnormal" style="margin-right:.01968em">l</span><span class="mord mathnormal">i</span><span class="mord mathnormal">t</span></span></span></span> 是将 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">x</span></span></span></span> 到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.625em;vertical-align:-.19444em"></span><span class="mord mathnormal" style="margin-right:.03588em">y</span></span></span></span> 的路径给提取出来，提取出来后这个路径也是一颗 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>p</mi><mi>l</mi><mi>a</mi><mi>y</mi></mrow><annotation encoding="application/x-tex">splay</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.8888799999999999em;vertical-align:-.19444em"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">p</span><span class="mord mathnormal" style="margin-right:.01968em">l</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:.03588em">y</span></span></span></span> ，那么我们得到了一棵这样的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>p</mi><mi>l</mi><mi>a</mi><mi>y</mi></mrow><annotation encoding="application/x-tex">splay</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.8888799999999999em;vertical-align:-.19444em"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">p</span><span class="mord mathnormal" style="margin-right:.01968em">l</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:.03588em">y</span></span></span></span> 就更方便我们对链上的信息进行维护。</p><p>代码实现如下</p><pre class="highlight"><code class="cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">split</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span>
</span>&#123;
    <span class="hljs-built_in">makeroot</span>(x);  <span class="hljs-comment">//让 x 变成根</span>
    <span class="hljs-built_in">access</span>(y);   <span class="hljs-comment">//然后给 y 和根建路径即可，其实就等于跟 x 建边</span>
&#125;
</code></pre><h2 id="link"><a class="markdownIt-Anchor" href="#link"></a> link</h2><p>这个函数应该是能猜出他是啥功能就是如果 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">x</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.625em;vertical-align:-.19444em"></span><span class="mord mathnormal" style="margin-right:.03588em">y</span></span></span></span> 不连通，那么就连一条边</p><p>代码实现如下</p><pre class="highlight"><code class="cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">link</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span>    <span class="hljs-comment">//如果 x 和 y 不连通，那么就连一条边</span>
</span>&#123;
    <span class="hljs-built_in">makeroot</span>(x);
    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">findroot</span>(y) != x)
        tr[x].fa = y;
&#125;
</code></pre><h2 id="cut"><a class="markdownIt-Anchor" href="#cut"></a> cut</h2><p>相当于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>i</mi><mi>n</mi><mi>k</mi></mrow><annotation encoding="application/x-tex">link</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.69444em;vertical-align:0"></span><span class="mord mathnormal" style="margin-right:.01968em">l</span><span class="mord mathnormal">i</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:.03148em">k</span></span></span></span> 的逆操作</p><pre class="highlight"><code class="cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">cut</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span>      <span class="hljs-comment">//如果 x 和 y 之间有边就删</span>
</span>&#123;
    <span class="hljs-built_in">makeroot</span>(x);
    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">findroot</span>(y) == x &amp;&amp; tr[y].fa == x &amp;&amp; !tr[y].s[<span class="hljs-number">0</span>])
    &#123;
        tr[x].s[<span class="hljs-number">1</span>] = tr[y].fa = <span class="hljs-number">0</span>;
        <span class="hljs-built_in">pushup</span>(x);
    &#125;
&#125;
</code></pre><h2 id="rotate-splay"><a class="markdownIt-Anchor" href="#rotate-splay"></a> rotate &amp; splay</h2><p>这里还是说一下吧，由于我们的这两个函数中都涉及到父子关系的改变，但是我们如果在更改过程中涉及到虚边和根节点之类的得特判，代码大体相同</p><pre class="highlight"><code class="cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">rotate</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span>   
</span>&#123;
    <span class="hljs-type">int</span> y = tr[x].fa, z = tr[y].fa;
    <span class="hljs-type">int</span> k = tr[y].s[<span class="hljs-number">1</span>] == x;
    <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">is_root</span>(y)) 
        tr[z].s[tr[z].s[<span class="hljs-number">1</span>] == y] = x;
    tr[x].fa = z;
    tr[y].s[k] = tr[x].s[k ^ <span class="hljs-number">1</span>], tr[tr[x].s[k ^ <span class="hljs-number">1</span>]].fa = y;
    tr[x].s[k ^ <span class="hljs-number">1</span>] = y, tr[y].fa = x;
    <span class="hljs-built_in">pushup</span>(y), <span class="hljs-built_in">pushup</span>(x);
&#125;

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">splay</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span>     <span class="hljs-comment">//正常的splay操作，但是在改变父子关系时要注意虚边的影响</span>
</span>&#123;
    <span class="hljs-type">int</span> top = <span class="hljs-number">0</span>, r = x;
    stk[++ top] = r;     <span class="hljs-comment">//下放懒标记时，因为操作时从下往上做，所以要从下开始释放懒标记</span>
    <span class="hljs-keyword">while</span>(!<span class="hljs-built_in">is_root</span>(r))
        stk[++ top] = r = tr[r].fa;
    <span class="hljs-keyword">while</span>(top)
        <span class="hljs-built_in">pushdown</span>(stk[top --]);
    <span class="hljs-keyword">while</span>(!<span class="hljs-built_in">is_root</span>(x))
    &#123;
        <span class="hljs-type">int</span> y = tr[x].fa, z = tr[y].fa;
        <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">is_root</span>(y))
        &#123;
            <span class="hljs-keyword">if</span>((tr[y].s[<span class="hljs-number">1</span>] == x) ^ (tr[z].s[<span class="hljs-number">1</span>] == y)) 
                <span class="hljs-built_in">rotate</span>(x);
            <span class="hljs-keyword">else</span> 
                <span class="hljs-built_in">rotate</span>(y);
        &#125;
        <span class="hljs-built_in">rotate</span>(x);
    &#125;
&#125;
</code></pre><p>终于！[LCT]{.rainbow} 的所有基本函数就都写完了，其实看着代码，还是比较好理解的，虽然多但是都挺短的，真要背也是比较好背。</p><h1 id="知識ポイントは終わりましたrainbow"><a class="markdownIt-Anchor" href="#知識ポイントは終わりましたrainbow"></a> [知識ポイントは終わりました]{.rainbow}</h1><p>除了 [LCT]{.rainbow} ，大家应该是做了许多的题了，那么这里就讲几道 [LCT]{.rainbow} 的例题来趁热打铁。</p><h1 id="例题rainbow"><a class="markdownIt-Anchor" href="#例题rainbow"></a> [例题]{.rainbow}</h1><h2 id="sdoi2008-洞穴勘测"><a class="markdownIt-Anchor" href="#sdoi2008-洞穴勘测"></a> <span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDIxNDc=">SDOI2008 洞穴勘测</span></h2><h3 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h3><p>辉辉有一台监测仪器可以实时将通道的每一次改变状况在辉辉手边的终端机上显示：</p><p>如果监测到洞穴u和洞穴v之间出现了一条通道，终端机上会显示一条指令 <code>Connect u v</code></p><p>如果监测到洞穴u和洞穴v之间的通道被毁，终端机上会显示一条指令 <code>Destroy u v</code></p><p>经过长期的艰苦卓绝的手工推算，辉辉发现一个奇怪的现象：无论通道怎么改变，任意时刻任意两个洞穴之间至多只有一条路径。</p><p>因而，辉辉坚信这是由于某种本质规律的支配导致的。因而，辉辉更加夜以继日地坚守在终端机之前，试图通过通道的改变情况来研究这条本质规律。 然而，终于有一天，辉辉在堆积成山的演算纸中崩溃了……他把终端机往地面一砸（终端机也足够坚固无法破坏），转而求助于你，说道：“你老兄把这程序写写吧”。</p><p>辉辉希望能随时通过终端机发出指令 <code>Query u v</code>，向监测仪询问此时洞穴u和洞穴v是否连通。现在你要为他编写程序回答每一次询问。 已知在第一条指令显示之前，JSZX洞穴群中没有任何通道存在。</p><h3 id="分析"><a class="markdownIt-Anchor" href="#分析"></a> 分析</h3><p>读完题干后我们就会立刻反应过来，这就是一个板子啊，维护树的连通性也算是一个题型吧，这个连边操作和删边操作太经典了，然后对于维护是否联通直接看一下是否同属于一颗 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mi>p</mi><mi>l</mi><mi>a</mi><mi>y</mi></mrow><annotation encoding="application/x-tex">Splay</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.8888799999999999em;vertical-align:-.19444em"></span><span class="mord mathnormal" style="margin-right:.05764em">S</span><span class="mord mathnormal">p</span><span class="mord mathnormal" style="margin-right:.01968em">l</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:.03588em">y</span></span></span></span> 即可，这个我们可以直接看一下是否时同一个根节点即可</p><pre class="highlight"><code class="cpp"><span class="hljs-keyword">namespace</span> LCT
&#123;
    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> read_write;

    <span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e6</span> + <span class="hljs-number">10</span>;

    <span class="hljs-type">int</span> stk[N];

    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Tree</span>
    &#123;
        <span class="hljs-type">int</span> s[<span class="hljs-number">2</span>], fa;
        <span class="hljs-type">int</span> rev;
    &#125; tr[N];

    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushrev</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span>
    </span>&#123;
        <span class="hljs-built_in">swap</span>(tr[x].s[<span class="hljs-number">0</span>], tr[x].s[<span class="hljs-number">1</span>]);
        tr[x].rev ^= <span class="hljs-number">1</span>;
    &#125;

    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushdown</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span>
    </span>&#123;
        <span class="hljs-keyword">if</span>(tr[x].rev)
        &#123;
            <span class="hljs-built_in">pushrev</span>(tr[x].s[<span class="hljs-number">0</span>]), <span class="hljs-built_in">pushrev</span>(tr[x].s[<span class="hljs-number">1</span>]);
            tr[x].rev = <span class="hljs-number">0</span>;
        &#125;
    &#125;

    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">is_root</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span>
    </span>&#123;
        <span class="hljs-keyword">return</span> (tr[tr[x].fa].s[<span class="hljs-number">0</span>] != x &amp;&amp; tr[tr[x].fa].s[<span class="hljs-number">1</span>] != x);   
    &#125;

    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">rotate</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span>
    </span>&#123;
        <span class="hljs-type">int</span> y = tr[x].fa, z = tr[y].fa;
        <span class="hljs-type">int</span> k = tr[y].s[<span class="hljs-number">1</span>] == x;
        <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">is_root</span>(y))
            tr[z].s[tr[z].s[<span class="hljs-number">1</span>] == y] = x;
        tr[x].fa = z;
        tr[y].s[k] = tr[x].s[k ^ <span class="hljs-number">1</span>], tr[tr[x].s[k ^ <span class="hljs-number">1</span>]].fa = y;
        tr[x].s[k ^ <span class="hljs-number">1</span>] = y, tr[y].fa = x;
    &#125;

    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">splay</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span>
    </span>&#123;
        <span class="hljs-type">int</span> top = <span class="hljs-number">0</span>, r = x;
        stk[++ top] = r;
        <span class="hljs-keyword">while</span>(!<span class="hljs-built_in">is_root</span>(r))
            stk[++ top] = r = tr[r].fa;
        <span class="hljs-keyword">while</span>(top)
            <span class="hljs-built_in">pushdown</span>(stk[top --]);
        <span class="hljs-keyword">while</span>(!<span class="hljs-built_in">is_root</span>(x))
        &#123;
            <span class="hljs-type">int</span> y = tr[x].fa, z = tr[y].fa;
            <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">is_root</span>(y))
            &#123;
                <span class="hljs-keyword">if</span>((tr[z].s[<span class="hljs-number">1</span>] == y) ^ (tr[y].s[<span class="hljs-number">1</span>] == x))
                    <span class="hljs-built_in">rotate</span>(x);
                <span class="hljs-keyword">else</span> 
                    <span class="hljs-built_in">rotate</span>(y);
            &#125;
            <span class="hljs-built_in">rotate</span>(x);
        &#125;
    &#125;

    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">access</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span>
    </span>&#123;
        <span class="hljs-type">int</span> z = x;
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> y = <span class="hljs-number">0</span> ; x ; y = x, x = tr[x].fa)
        &#123;
            <span class="hljs-built_in">splay</span>(x);
            tr[x].s[<span class="hljs-number">1</span>] = y;
        &#125;
        <span class="hljs-built_in">splay</span>(z);
    &#125;

    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">makeroot</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span>
    </span>&#123;
        <span class="hljs-built_in">access</span>(x);
        <span class="hljs-built_in">pushrev</span>(x);
    &#125;

    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findroot</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span>
    </span>&#123;   
        <span class="hljs-built_in">access</span>(x);
        <span class="hljs-keyword">while</span>(tr[x].s[<span class="hljs-number">0</span>])
            <span class="hljs-built_in">pushdown</span>(x), x = tr[x].s[<span class="hljs-number">0</span>];
        <span class="hljs-built_in">splay</span>(x);
        <span class="hljs-keyword">return</span> x;
    &#125;

    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">link</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span>
    </span>&#123;
        <span class="hljs-built_in">makeroot</span>(x);
        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">findroot</span>(y) != x)
            tr[x].fa = y;
    &#125;

    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">cut</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span>
    </span>&#123;
        <span class="hljs-built_in">makeroot</span>(x);
        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">findroot</span>(y) == x &amp;&amp; tr[y].fa == x &amp;&amp; !tr[y].s[<span class="hljs-number">0</span>])
            tr[x].s[<span class="hljs-number">1</span>] = tr[y].fa = <span class="hljs-number">0</span>;
    &#125;
&#125;

<span class="hljs-keyword">namespace</span> Solve
&#123;
    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> LCT;

    <span class="hljs-type">int</span> n, m;
    <span class="hljs-type">char</span> op[<span class="hljs-number">20</span>];

    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span>
    </span>&#123;
        <span class="hljs-built_in">read</span>(n), <span class="hljs-built_in">read</span>(m);

        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= m ; ++ i)
        &#123;
            <span class="hljs-type">int</span> u, v;
            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>, op);
            <span class="hljs-built_in">read</span>(u), <span class="hljs-built_in">read</span>(v);
            <span class="hljs-keyword">if</span>(*op == <span class="hljs-string">&#x27;C&#x27;</span>)
                <span class="hljs-built_in">link</span>(u, v);
            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(*op == <span class="hljs-string">&#x27;D&#x27;</span>)
                <span class="hljs-built_in">cut</span>(u, v);
            <span class="hljs-keyword">else</span> 
            &#123;
                <span class="hljs-keyword">if</span>(<span class="hljs-built_in">findroot</span>(u) == <span class="hljs-built_in">findroot</span>(v))
                    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Yes&quot;</span>);
                <span class="hljs-keyword">else</span> 
                    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;No&quot;</span>);
            &#125;
        &#125;
    &#125;
&#125;
</code></pre><h2 id="国家集训队-tree-ii"><a class="markdownIt-Anchor" href="#国家集训队-tree-ii"></a> <span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDE1MDE=">国家集训队 Tree II</span></h2><h3 id="题目描述-2"><a class="markdownIt-Anchor" href="#题目描述-2"></a> 题目描述</h3><p>一棵 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">n</span></span></span></span> 个点的树，每个点的初始权值为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">1</span></span></span></span>。<br>对于这棵树有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>q</mi></mrow><annotation encoding="application/x-tex">q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.625em;vertical-align:-.19444em"></span><span class="mord mathnormal" style="margin-right:.03588em">q</span></span></span></span> 个操作，每个操作为以下四种操作之一：</p><ul><li><code>+ u v c</code>：将 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">u</span></span></span></span> 到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal" style="margin-right:.03588em">v</span></span></span></span> 的路径上的点的权值都加上自然数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex">c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">c</span></span></span></span>；</li><li><code>- u1 v1 u2 v2</code>：将树中原有的边 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>u</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>v</mi><mn>1</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(u_1,v_1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">u</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.30110799999999993em"><span style="top:-2.5500000000000003em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.03588em">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.30110799999999993em"><span style="top:-2.5500000000000003em;margin-left:-.03588em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 删除，加入一条新边 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>u</mi><mn>2</mn></msub><mo separator="true">,</mo><msub><mi>v</mi><mn>2</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(u_2,v_2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">u</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.30110799999999993em"><span style="top:-2.5500000000000003em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.03588em">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.30110799999999993em"><span style="top:-2.5500000000000003em;margin-left:-.03588em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，保证操作完之后仍然是一棵树；</li><li><code>* u v c</code>：将 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">u</span></span></span></span> 到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal" style="margin-right:.03588em">v</span></span></span></span> 的路径上的点的权值都乘上自然数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex">c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">c</span></span></span></span>；</li><li><code>/ u v</code>：询问 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">u</span></span></span></span> 到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal" style="margin-right:.03588em">v</span></span></span></span> 的路径上的点的权值和，将答案对 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>51061</mn></mrow><annotation encoding="application/x-tex">51061</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">5</span><span class="mord">1</span><span class="mord">0</span><span class="mord">6</span><span class="mord">1</span></span></span></span> 取模。</li></ul><h3 id="输入格式"><a class="markdownIt-Anchor" href="#输入格式"></a> 输入格式</h3><p>第一行两个整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo separator="true">,</mo><mi>q</mi></mrow><annotation encoding="application/x-tex">n,q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.625em;vertical-align:-.19444em"></span><span class="mord mathnormal">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord mathnormal" style="margin-right:.03588em">q</span></span></span></span>。</p><p>接下来 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.66666em;vertical-align:-.08333em"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">1</span></span></span></span> 行每行两个正整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi><mo separator="true">,</mo><mi>v</mi></mrow><annotation encoding="application/x-tex">u,v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.625em;vertical-align:-.19444em"></span><span class="mord mathnormal">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord mathnormal" style="margin-right:.03588em">v</span></span></span></span>，描述这棵树的每条边。</p><p>接下来 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>q</mi></mrow><annotation encoding="application/x-tex">q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.625em;vertical-align:-.19444em"></span><span class="mord mathnormal" style="margin-right:.03588em">q</span></span></span></span> 行，每行描述一个操作。</p><h3 id="输出格式"><a class="markdownIt-Anchor" href="#输出格式"></a> 输出格式</h3><p>对于每个询问操作，输出一行一个整数表示答案。</p><h3 id="分析-2"><a class="markdownIt-Anchor" href="#分析-2"></a> 分析</h3><p>首先这个题考察的是 [LCT]{.rainbow} 维护树链信息，其实也比较的板子，而且非常锻炼码力和细节，首先断边和加边的基本操作就不用再说了，我们这里看一下我们如何对一条路径的信息进行维护，我们是有一个 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>p</mi><mi>l</mi><mi>i</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">split</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.8888799999999999em;vertical-align:-.19444em"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">p</span><span class="mord mathnormal" style="margin-right:.01968em">l</span><span class="mord mathnormal">i</span><span class="mord mathnormal">t</span></span></span></span> 函数的，它的作用就是将一段路径给分离出来，然后我们还是知道分离出来后的根的，所以这就非常方便我们进行操作了，分离出来后我们直接进行按照 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>p</mi><mi>l</mi><mi>a</mi><mi>y</mi></mrow><annotation encoding="application/x-tex">splay</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.8888799999999999em;vertical-align:-.19444em"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">p</span><span class="mord mathnormal" style="margin-right:.01968em">l</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:.03588em">y</span></span></span></span> 的维护方式维护即可，注意乘法和加法在下放时候的优先级。</p><p>代码如下</p><pre class="highlight"><code class="cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span>

<span class="hljs-keyword">namespace</span> read_write
&#123;
    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">read</span><span class="hljs-params">(T &amp;x)</span>
    </span>&#123;
        x = <span class="hljs-number">0</span>;
        T f = <span class="hljs-number">1</span>;
        <span class="hljs-type">char</span> ch = <span class="hljs-built_in">getchar</span>();
        <span class="hljs-keyword">while</span> (ch &gt; <span class="hljs-string">&#x27;9&#x27;</span> || ch &lt; <span class="hljs-string">&#x27;0&#x27;</span>)
        &#123;
            <span class="hljs-keyword">if</span> (ch == <span class="hljs-string">&#x27;-&#x27;</span>)
                f = <span class="hljs-number">-1</span>;
            ch = <span class="hljs-built_in">getchar</span>();
        &#125;
        <span class="hljs-keyword">while</span> (ch &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="hljs-string">&#x27;9&#x27;</span>)
            x = x * <span class="hljs-number">10</span> + ch - <span class="hljs-string">&#x27;0&#x27;</span>, ch = <span class="hljs-built_in">getchar</span>();
        x *= f;
        <span class="hljs-keyword">return</span>;
    &#125;

    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">write</span><span class="hljs-params">(T x)</span>
    </span>&#123;
        <span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">0</span>)
        &#123;
            x = -x;
            <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;-&#x27;</span>);
        &#125;
        <span class="hljs-keyword">if</span> (x &gt; <span class="hljs-number">9</span>)
            <span class="hljs-built_in">write</span>(x / <span class="hljs-number">10</span>);
        <span class="hljs-built_in">putchar</span>(x % <span class="hljs-number">10</span> + <span class="hljs-string">&#x27;0&#x27;</span>);
    &#125;

    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
    <span class="hljs-function">T <span class="hljs-title">max</span><span class="hljs-params">(T x, T y)</span>
    </span>&#123;
        <span class="hljs-keyword">return</span> x &gt; y ? x : y;
    &#125;

    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
    <span class="hljs-function">T <span class="hljs-title">min</span><span class="hljs-params">(T x, T y)</span>
    </span>&#123;
        <span class="hljs-keyword">return</span> x &gt; y ? y : x;
    &#125;

    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(T &amp;a, T &amp;b)</span>
    </span>&#123;
        T tem = b;
        b = a;
        a = tem;
    &#125;
&#125;

<span class="hljs-keyword">namespace</span> LCT
&#123;
    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> read_write;

    <span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span>

    <span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e6</span> + <span class="hljs-number">10</span>, mod = <span class="hljs-number">51061</span>;

    <span class="hljs-type">int</span> n, q;
    <span class="hljs-type">int</span> stk[N];
    <span class="hljs-type">char</span> op[<span class="hljs-number">2</span>];

    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Tree</span>
    &#123;
        <span class="hljs-type">int</span> s[<span class="hljs-number">2</span>], v, siz, fa;
        <span class="hljs-type">int</span> sum, add, mul, rev;
    &#125; tr[N];

    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushup</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span>
    </span>&#123;
        tr[x].siz = tr[tr[x].s[<span class="hljs-number">0</span>]].siz + tr[tr[x].s[<span class="hljs-number">1</span>]].siz + <span class="hljs-number">1</span>;
        tr[x].sum = tr[tr[x].s[<span class="hljs-number">0</span>]].v + tr[tr[x].s[<span class="hljs-number">1</span>]].v + tr[x].v % mod;
    &#125;

    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushrev</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span>
    </span>&#123;
        <span class="hljs-built_in">swap</span>(tr[x].s[<span class="hljs-number">0</span>], tr[x].s[<span class="hljs-number">1</span>]);
        tr[x].rev ^= <span class="hljs-number">1</span>;
    &#125;

    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushdown</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span>
    </span>&#123;   
        <span class="hljs-keyword">if</span>(tr[x].mul != <span class="hljs-number">1</span>)
        &#123;
            <span class="hljs-keyword">if</span>(tr[x].s[<span class="hljs-number">0</span>])
            &#123;
                tr[tr[x].s[<span class="hljs-number">0</span>]].v = tr[tr[x].s[<span class="hljs-number">0</span>]].v * tr[x].mul % mod;
                tr[tr[x].s[<span class="hljs-number">0</span>]].mul = tr[tr[x].s[<span class="hljs-number">0</span>]].mul * tr[x].mul % mod;
                tr[tr[x].s[<span class="hljs-number">0</span>]].add = tr[tr[x].s[<span class="hljs-number">0</span>]].add * tr[x].mul % mod;
                tr[tr[x].s[<span class="hljs-number">0</span>]].sum = tr[tr[x].s[<span class="hljs-number">0</span>]].sum * tr[x].mul % mod;
            &#125;

            <span class="hljs-keyword">if</span>(tr[x].s[<span class="hljs-number">1</span>])
            &#123;
                tr[tr[x].s[<span class="hljs-number">1</span>]].v = tr[tr[x].s[<span class="hljs-number">1</span>]].v * tr[x].mul % mod;
                tr[tr[x].s[<span class="hljs-number">1</span>]].mul = tr[tr[x].s[<span class="hljs-number">1</span>]].mul * tr[x].mul % mod;
                tr[tr[x].s[<span class="hljs-number">1</span>]].add = tr[tr[x].s[<span class="hljs-number">1</span>]].add * tr[x].mul % mod;
                tr[tr[x].s[<span class="hljs-number">1</span>]].sum = tr[tr[x].s[<span class="hljs-number">1</span>]].sum * tr[x].mul % mod;
            &#125;

            tr[x].mul = <span class="hljs-number">1</span>;
        &#125;

        <span class="hljs-keyword">if</span>(tr[x].add)
        &#123;
            <span class="hljs-keyword">if</span>(tr[x].s[<span class="hljs-number">0</span>])
            &#123;
                tr[tr[x].s[<span class="hljs-number">0</span>]].v = tr[tr[x].s[<span class="hljs-number">0</span>]].v + tr[x].add % mod;
                tr[tr[x].s[<span class="hljs-number">0</span>]].add = tr[tr[x].s[<span class="hljs-number">0</span>]].add + tr[x].add % mod;
                tr[tr[x].s[<span class="hljs-number">0</span>]].sum = (tr[tr[x].s[<span class="hljs-number">0</span>]].sum + tr[tr[x].s[<span class="hljs-number">0</span>]].siz * tr[x].add % mod) % mod;
            &#125;

            <span class="hljs-keyword">if</span>(tr[x].s[<span class="hljs-number">1</span>])
            &#123;
                tr[tr[x].s[<span class="hljs-number">1</span>]].v = tr[tr[x].s[<span class="hljs-number">1</span>]].v + tr[x].add % mod;
                tr[tr[x].s[<span class="hljs-number">1</span>]].add = tr[tr[x].s[<span class="hljs-number">1</span>]].add + tr[x].add % mod;
                tr[tr[x].s[<span class="hljs-number">1</span>]].sum = (tr[tr[x].s[<span class="hljs-number">1</span>]].sum + tr[tr[x].s[<span class="hljs-number">1</span>]].siz * tr[x].add % mod) % mod;
            &#125;

            tr[x].add = <span class="hljs-number">0</span>;
        &#125;

        <span class="hljs-keyword">if</span>(tr[x].rev)
        &#123;
            <span class="hljs-built_in">pushrev</span>(tr[x].s[<span class="hljs-number">0</span>]), <span class="hljs-built_in">pushrev</span>(tr[x].s[<span class="hljs-number">1</span>]);
            tr[x].rev = <span class="hljs-number">0</span>;
        &#125;
    &#125;

    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">is_root</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span>
    </span>&#123;
        <span class="hljs-keyword">return</span> (tr[tr[x].fa].s[<span class="hljs-number">0</span>] != x &amp;&amp; tr[tr[x].fa].s[<span class="hljs-number">1</span>] != x);
    &#125;

    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">rotate</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span>
    </span>&#123;
        <span class="hljs-type">int</span> y = tr[x].fa, z = tr[y].fa;
        <span class="hljs-type">int</span> k = tr[y].s[<span class="hljs-number">1</span>] == x;
        <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">is_root</span>(y))
            tr[z].s[tr[z].s[<span class="hljs-number">1</span>] == y] = x;
        tr[x].fa = z;
        tr[y].s[k] = tr[x].s[k ^ <span class="hljs-number">1</span>], tr[tr[x].s[k ^ <span class="hljs-number">1</span>]].fa = y;
        tr[x].s[k ^ <span class="hljs-number">1</span>] = y, tr[y].fa = x;
        <span class="hljs-built_in">pushup</span>(y), <span class="hljs-built_in">pushup</span>(x);
    &#125;

    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">splay</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span>
    </span>&#123;
        <span class="hljs-type">int</span> top = <span class="hljs-number">0</span>, r = x;
        stk[++ top] = r;
        <span class="hljs-keyword">while</span>(!<span class="hljs-built_in">is_root</span>(r))
            stk[++ top] = r = tr[r].fa;
        <span class="hljs-keyword">while</span>(top)
            <span class="hljs-built_in">pushdown</span>(stk[top --]);
        <span class="hljs-keyword">while</span>(!<span class="hljs-built_in">is_root</span>(x))
        &#123;
            <span class="hljs-type">int</span> y = tr[x].fa, z = tr[y].fa;
            <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">is_root</span>(y))
            &#123;
                <span class="hljs-keyword">if</span>((tr[z].s[<span class="hljs-number">1</span>] == y) ^ (tr[y].s[<span class="hljs-number">1</span>] == x))
                    <span class="hljs-built_in">rotate</span>(x);
                <span class="hljs-keyword">else</span> 
                    <span class="hljs-built_in">rotate</span>(y);
            &#125;
            <span class="hljs-built_in">rotate</span>(x);
        &#125;
    &#125;

    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">access</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span>
    </span>&#123;
        <span class="hljs-type">int</span> z = x;
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> y = <span class="hljs-number">0</span> ; x ; y = x, x = tr[x].fa)
        &#123;
            <span class="hljs-built_in">splay</span>(x);
            tr[x].s[<span class="hljs-number">1</span>] = y;
            <span class="hljs-built_in">pushup</span>(x);
        &#125;
        <span class="hljs-built_in">splay</span>(z);
    &#125;

    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">makeroot</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span>
    </span>&#123;
        <span class="hljs-built_in">access</span>(x);
        <span class="hljs-built_in">pushrev</span>(x);
    &#125;

    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findroot</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span>
    </span>&#123;
        <span class="hljs-built_in">access</span>(x);
        <span class="hljs-keyword">while</span>(tr[x].s[<span class="hljs-number">0</span>])
            <span class="hljs-built_in">splay</span>(x), x = tr[x].s[<span class="hljs-number">0</span>];
        <span class="hljs-built_in">splay</span>(x);
        <span class="hljs-keyword">return</span> x;
    &#125;

    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">link</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span>
    </span>&#123;
        <span class="hljs-built_in">makeroot</span>(x);
        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">findroot</span>(y) != x)
            tr[x].fa = y;
    &#125;

    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">cut</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span>
    </span>&#123;
        <span class="hljs-built_in">makeroot</span>(x);
        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">findroot</span>(y) == x &amp;&amp; tr[y].fa == x &amp;&amp; !tr[y].s[<span class="hljs-number">0</span>])
        &#123;
            tr[x].s[<span class="hljs-number">1</span>] = tr[y].fa = <span class="hljs-number">0</span>;
            <span class="hljs-built_in">pushup</span>(x);
        &#125;
    &#125;

    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">split</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span>
    </span>&#123;
        <span class="hljs-built_in">makeroot</span>(x);
        <span class="hljs-built_in">access</span>(y);
    &#125;
&#125;

<span class="hljs-keyword">namespace</span> Solve
&#123;
    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> LCT;

    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span>
    </span>&#123;
        <span class="hljs-built_in">read</span>(n), <span class="hljs-built_in">read</span>(q);

        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; ++ i)
            tr[i].v = tr[i].mul = tr[i].siz = <span class="hljs-number">1</span>;
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt; n ; ++ i)
        &#123;
            <span class="hljs-type">int</span> u, v;
            <span class="hljs-built_in">read</span>(u), <span class="hljs-built_in">read</span>(v);
            <span class="hljs-built_in">link</span>(u, v);
        &#125;

        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= q ; ++ i)
        &#123;
            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>, op);
            <span class="hljs-keyword">if</span>(*op == <span class="hljs-string">&#x27;+&#x27;</span>)
            &#123;
                <span class="hljs-type">int</span> u, v, c;
                <span class="hljs-built_in">read</span>(u), <span class="hljs-built_in">read</span>(v), <span class="hljs-built_in">read</span>(c);
                <span class="hljs-built_in">split</span>(u, v);
                
                tr[v].v = tr[v].v + c % mod;
                tr[v].add = tr[v].add + c % mod;
                tr[v].sum = (tr[v].sum + c * tr[v].siz % mod) % mod;
                <span class="hljs-built_in">pushup</span>(v);
            &#125;
            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(*op == <span class="hljs-string">&#x27;-&#x27;</span>)
            &#123;
                <span class="hljs-type">int</span> u1, v1, u2, v2;
                <span class="hljs-built_in">read</span>(u1), <span class="hljs-built_in">read</span>(v1), <span class="hljs-built_in">read</span>(u2), <span class="hljs-built_in">read</span>(v2);
                <span class="hljs-built_in">cut</span>(u1, v1), <span class="hljs-built_in">link</span>(u2, v2);
            &#125;
            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(*op == <span class="hljs-string">&#x27;*&#x27;</span>)
            &#123;
                <span class="hljs-type">int</span> u, v, c;
                <span class="hljs-built_in">read</span>(u), <span class="hljs-built_in">read</span>(v), <span class="hljs-built_in">read</span>(c);
                <span class="hljs-built_in">split</span>(u, v);

                tr[v].sum = tr[v].sum * c % mod;
                tr[v].v = tr[v].v * c % mod;
                tr[v].mul = tr[v].mul * c % mod;
                <span class="hljs-built_in">pushup</span>(v);
            &#125;
            <span class="hljs-keyword">else</span> 
            &#123;
                <span class="hljs-type">int</span> u, v;
                <span class="hljs-built_in">read</span>(u), <span class="hljs-built_in">read</span>(v);
                <span class="hljs-built_in">split</span>(u, v);

                <span class="hljs-built_in">write</span>(tr[v].sum % mod), <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);
            &#125;
        &#125;
    &#125;
&#125;

<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>&#123;
    <span class="hljs-comment">// freopen(&quot;test.in&quot;, &quot;r&quot;, stdin);</span>
    <span class="hljs-comment">// freopen(&quot;test.out&quot;, &quot;w&quot;, stdout);</span>

    Solve :: <span class="hljs-built_in">solve</span>();

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;
</code></pre><h2 id="最小差值生成树"><a class="markdownIt-Anchor" href="#最小差值生成树"></a> <span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDQyMzQ=">最小差值生成树</span></h2><h3 id="题目描述-3"><a class="markdownIt-Anchor" href="#题目描述-3"></a> 题目描述</h3><p>给定一个点标号从 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">1</span></span></span></span> 到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">n</span></span></span></span> 的、有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">m</span></span></span></span> 条边的无向图，求边权最大值与最小值的差值最小的生成树。图可能存在自环。</p><h3 id="输入格式-2"><a class="markdownIt-Anchor" href="#输入格式-2"></a> 输入格式</h3><p>第一行有两个整数，表示图的点数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">n</span></span></span></span> 和边数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">m</span></span></span></span>。</p><p>接下来 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">m</span></span></span></span> 行，每行三个整数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi><mo separator="true">,</mo><mi>v</mi><mo separator="true">,</mo><mi>w</mi></mrow><annotation encoding="application/x-tex">u, v, w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.625em;vertical-align:-.19444em"></span><span class="mord mathnormal">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord mathnormal" style="margin-right:.03588em">v</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord mathnormal" style="margin-right:.02691em">w</span></span></span></span>，表示存在一条连接 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi><mo separator="true">,</mo><mi>v</mi></mrow><annotation encoding="application/x-tex">u, v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.625em;vertical-align:-.19444em"></span><span class="mord mathnormal">u</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord mathnormal" style="margin-right:.03588em">v</span></span></span></span> 长度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi></mrow><annotation encoding="application/x-tex">w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal" style="margin-right:.02691em">w</span></span></span></span> 的边。</p><h3 id="输出格式-2"><a class="markdownIt-Anchor" href="#输出格式-2"></a> 输出格式</h3><p>输出一行一个整数，表示答案。</p><hr><h3 id="分析-3"><a class="markdownIt-Anchor" href="#分析-3"></a> 分析</h3><p>这是讲的最后一道例题了，应该至此 [LCT]{.rainbow} 的所有题型应该是都涉及到了，这个考察的是 [LCT]{.rainbow} 维护边权，这里不得不要提一个小技巧了，对于一般的树上问题，如果是静态的，我们处理边权的手段往往都是将边权下放到这条边中深度更深的点上，但是一旦整棵树动了起来，我们维护边权的时候就要将一条边拆成一个点，那么我们只需让该点连接这两个点。对于这个题我们仍可以贪心的求，当我们出现了一条返租边时，我们将最小的边删去加入这个更大的边一定是更优的，因为当我们的最大值一定的时候，最小值更大是一定符合最优解的。</p><p>代码实现如下</p><pre class="highlight"><code class="cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span>

<span class="hljs-keyword">namespace</span> read_write
&#123;
    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">read</span><span class="hljs-params">(T &amp;x)</span>
    </span>&#123;
        x = <span class="hljs-number">0</span>;
        T f = <span class="hljs-number">1</span>;
        <span class="hljs-type">char</span> ch = <span class="hljs-built_in">getchar</span>();
        <span class="hljs-keyword">while</span> (ch &gt; <span class="hljs-string">&#x27;9&#x27;</span> || ch &lt; <span class="hljs-string">&#x27;0&#x27;</span>)
        &#123;
            <span class="hljs-keyword">if</span> (ch == <span class="hljs-string">&#x27;-&#x27;</span>)
                f = <span class="hljs-number">-1</span>;
            ch = <span class="hljs-built_in">getchar</span>();
        &#125;
        <span class="hljs-keyword">while</span> (ch &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="hljs-string">&#x27;9&#x27;</span>)
            x = x * <span class="hljs-number">10</span> + ch - <span class="hljs-string">&#x27;0&#x27;</span>, ch = <span class="hljs-built_in">getchar</span>();
        x *= f;
        <span class="hljs-keyword">return</span>;
    &#125;

    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">write</span><span class="hljs-params">(T x)</span>
    </span>&#123;
        <span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">0</span>)
        &#123;
            x = -x;
            <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;-&#x27;</span>);
        &#125;
        <span class="hljs-keyword">if</span> (x &gt; <span class="hljs-number">9</span>)
            <span class="hljs-built_in">write</span>(x / <span class="hljs-number">10</span>);
        <span class="hljs-built_in">putchar</span>(x % <span class="hljs-number">10</span> + <span class="hljs-string">&#x27;0&#x27;</span>);
    &#125;

    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
    <span class="hljs-function">T <span class="hljs-title">max</span><span class="hljs-params">(T x, T y)</span>
    </span>&#123;
        <span class="hljs-keyword">return</span> x &gt; y ? x : y;
    &#125;

    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
    <span class="hljs-function">T <span class="hljs-title">min</span><span class="hljs-params">(T x, T y)</span>
    </span>&#123;
        <span class="hljs-keyword">return</span> x &gt; y ? y : x;
    &#125;

    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(T &amp;a, T &amp;b)</span>
    </span>&#123;
        T tem = b;
        b = a;
        a = tem;
    &#125;
&#125;

<span class="hljs-keyword">namespace</span> LCT
&#123;
    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> read_write;

    <span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e6</span> + <span class="hljs-number">10</span>, INF = <span class="hljs-number">0x3f3f3f3f</span>;

    <span class="hljs-type">int</span> n, m, cnt;
    <span class="hljs-type">int</span> stk[N];

    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Tree</span>
    &#123;
        <span class="hljs-type">int</span> s[<span class="hljs-number">2</span>], id;
        <span class="hljs-type">int</span> rev, fa;
    &#125; tr[N];

    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushup</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span>
    </span>&#123;
        tr[u].id = u;
        <span class="hljs-keyword">if</span>(tr[tr[u].s[<span class="hljs-number">0</span>]].id &gt; n &amp;&amp; (tr[u].id &lt;= n || tr[u].id &gt; tr[tr[u].s[<span class="hljs-number">0</span>]].id))
            tr[u].id = tr[tr[u].s[<span class="hljs-number">0</span>]].id;
        <span class="hljs-keyword">if</span>(tr[tr[u].s[<span class="hljs-number">1</span>]].id &gt; n &amp;&amp; (tr[u].id &lt;= n || tr[u].id &gt; tr[tr[u].s[<span class="hljs-number">1</span>]].id))
            tr[u].id = tr[tr[u].s[<span class="hljs-number">1</span>]].id;
    &#125;

    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushrev</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span>
    </span>&#123;
        <span class="hljs-built_in">swap</span>(tr[x].s[<span class="hljs-number">0</span>], tr[x].s[<span class="hljs-number">1</span>]);
        tr[x].rev ^= <span class="hljs-number">1</span>;
    &#125;

    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushdown</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span>
    </span>&#123;
        <span class="hljs-keyword">if</span>(tr[x].rev)
        &#123;
            <span class="hljs-built_in">pushrev</span>(tr[x].s[<span class="hljs-number">0</span>]), <span class="hljs-built_in">pushrev</span>(tr[x].s[<span class="hljs-number">1</span>]);
            tr[x].rev = <span class="hljs-number">0</span>;
        &#125;
    &#125;

    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">is_root</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span>
    </span>&#123;
        <span class="hljs-keyword">return</span> (tr[tr[x].fa].s[<span class="hljs-number">0</span>] != x &amp;&amp; tr[tr[x].fa].s[<span class="hljs-number">1</span>] != x);
    &#125;

    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">rotate</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span>
    </span>&#123;
        <span class="hljs-type">int</span> y = tr[x].fa, z = tr[y].fa;
        <span class="hljs-type">int</span> k = tr[y].s[<span class="hljs-number">1</span>] == x;
        <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">is_root</span>(y))
            tr[z].s[tr[z].s[<span class="hljs-number">1</span>] == y] = x;
        tr[x].fa = z;
        tr[y].s[k] = tr[x].s[k ^ <span class="hljs-number">1</span>], tr[tr[x].s[k ^ <span class="hljs-number">1</span>]].fa = y;
        tr[x].s[k ^ <span class="hljs-number">1</span>] = y, tr[y].fa = x;
        <span class="hljs-built_in">pushup</span>(y), <span class="hljs-built_in">pushup</span>(x);
    &#125;

    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">splay</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span>
    </span>&#123;
        <span class="hljs-type">int</span> top = <span class="hljs-number">0</span>, r = x;
        stk[++ top] = r;
        <span class="hljs-keyword">while</span>(!<span class="hljs-built_in">is_root</span>(r))
            stk[++ top] = r = tr[r].fa;
        <span class="hljs-keyword">while</span>(top)
            <span class="hljs-built_in">pushdown</span>(stk[top --]);
        <span class="hljs-keyword">while</span>(!<span class="hljs-built_in">is_root</span>(x))
        &#123;
            <span class="hljs-type">int</span> y = tr[x].fa, z = tr[y].fa;
            <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">is_root</span>(y))
            &#123;
                <span class="hljs-keyword">if</span>((tr[z].s[<span class="hljs-number">1</span>] == y) ^ (tr[y].s[<span class="hljs-number">1</span>] == x))
                    <span class="hljs-built_in">rotate</span>(x);
                <span class="hljs-keyword">else</span> 
                    <span class="hljs-built_in">rotate</span>(y);
            &#125;
            <span class="hljs-built_in">rotate</span>(x);
        &#125;
    &#125;

    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">access</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span>
    </span>&#123;
        <span class="hljs-type">int</span> z = x;
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> y = <span class="hljs-number">0</span> ; x ; y = x, x = tr[x].fa)
        &#123;
            <span class="hljs-built_in">splay</span>(x);
            tr[x].s[<span class="hljs-number">1</span>] = y;
            <span class="hljs-built_in">pushup</span>(x);
        &#125;
        <span class="hljs-built_in">splay</span>(z);
    &#125;

    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">makeroot</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span>
    </span>&#123;
        <span class="hljs-built_in">access</span>(x);
        <span class="hljs-built_in">pushrev</span>(x);
    &#125;

    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findroot</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span>
    </span>&#123;
        <span class="hljs-built_in">access</span>(x);
        <span class="hljs-keyword">while</span>(tr[x].s[<span class="hljs-number">0</span>])
            <span class="hljs-built_in">pushdown</span>(x), x = tr[x].s[<span class="hljs-number">0</span>];
        <span class="hljs-built_in">splay</span>(x);
        <span class="hljs-keyword">return</span> x;
    &#125;

    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">split</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span>
    </span>&#123;
        <span class="hljs-built_in">makeroot</span>(x);
        <span class="hljs-built_in">access</span>(y);
    &#125;

    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">link</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span>
    </span>&#123;
        <span class="hljs-built_in">makeroot</span>(x);
        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">findroot</span>(y) != x)
            tr[x].fa = y;
    &#125;

    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">cut</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span>
    </span>&#123;
        <span class="hljs-built_in">makeroot</span>(x);
        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">findroot</span>(y) == x &amp;&amp; tr[y].fa == x &amp;&amp; !tr[y].s[<span class="hljs-number">0</span>])
        &#123;
            tr[x].s[<span class="hljs-number">1</span>] = tr[y].fa = <span class="hljs-number">0</span>;
            <span class="hljs-built_in">pushup</span>(x);
        &#125;
    &#125;

    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span>
    </span>&#123;
        <span class="hljs-built_in">makeroot</span>(x);
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">findroot</span>(y) != x;
    &#125;
&#125;

<span class="hljs-keyword">namespace</span> Solve
&#123;
    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> LCT;

    <span class="hljs-type">int</span> sum, ans, pos, tot;
    <span class="hljs-type">bool</span> st[N];

    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span>
    &#123;
        <span class="hljs-type">int</span> u, v, w;

        <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span> &lt; (<span class="hljs-type">const</span> Edge &amp;a) <span class="hljs-type">const</span> &#123;<span class="hljs-keyword">return</span> w &lt; a.w;&#125;
    &#125; e[N];

    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span>
    </span>&#123;
        <span class="hljs-built_in">read</span>(n), <span class="hljs-built_in">read</span>(m);
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= m ; ++ i)
        &#123;
            <span class="hljs-type">int</span> u, v, w;
            <span class="hljs-built_in">read</span>(u), <span class="hljs-built_in">read</span>(v), <span class="hljs-built_in">read</span>(w);
            e[i] = &#123;u, v, w&#125;;
        &#125;

        cnt = n, sum = <span class="hljs-number">1</span>, ans = INF;
        std :: <span class="hljs-built_in">sort</span>(e + <span class="hljs-number">1</span>, e + m + <span class="hljs-number">1</span>);

        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= m ; ++ i)
        &#123;
            ++ cnt;
            <span class="hljs-type">int</span> x = e[i].u, y = e[i].v;
            <span class="hljs-keyword">if</span>(x == y)
            &#123;
                st[i] = <span class="hljs-literal">true</span>;
                <span class="hljs-keyword">continue</span>;
            &#125;

            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">check</span>(x, y))
                <span class="hljs-built_in">link</span>(x, cnt), <span class="hljs-built_in">link</span>(cnt, y), ++ tot;
            <span class="hljs-keyword">else</span>
            &#123;
                <span class="hljs-built_in">split</span>(x, y);
                pos = tr[y].id;
                st[pos - n] = <span class="hljs-literal">true</span>, <span class="hljs-built_in">splay</span>(pos);

                tr[tr[pos].s[<span class="hljs-number">0</span>]].fa = tr[tr[pos].s[<span class="hljs-number">1</span>]].fa = <span class="hljs-number">0</span>;
                <span class="hljs-built_in">link</span>(x, cnt), <span class="hljs-built_in">link</span>(cnt, y);
            &#125;

            <span class="hljs-keyword">while</span>(st[sum] &amp;&amp; sum &lt;= i)
                ++ sum;
            <span class="hljs-keyword">if</span>(tot &gt;= n - <span class="hljs-number">1</span>)
                ans = <span class="hljs-built_in">min</span>(ans, e[i].w - e[sum].w);
        &#125;

        <span class="hljs-built_in">write</span>(ans);
    &#125;
&#125;

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>&#123;
    Solve :: <span class="hljs-built_in">solve</span>();

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;
</code></pre><h2 id="sdoi2017-树点涂色"><a class="markdownIt-Anchor" href="#sdoi2017-树点涂色"></a> <span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3Byb2JsZW0vUDM3MDM=">SDOI2017 树点涂色</span></h2><h3 id="题目描述-4"><a class="markdownIt-Anchor" href="#题目描述-4"></a> 题目描述</h3><p>Bob 有一棵 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">n</span></span></span></span> 个点的有根树，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.64444em;vertical-align:0"></span><span class="mord">1</span></span></span></span> 号点是根节点。Bob 在每个点上涂了颜色，并且每个点上的颜色不同。</p><p>定义一条路径的权值是：这条路径上的点（包括起点和终点）共有多少种不同的颜色。</p><p>Bob可能会进行这几种操作：</p><ul><li><p><code>1 x</code> 表示把点 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">x</span></span></span></span> 到根节点的路径上所有的点染上一种没有用过的新颜色。</p></li><li><p><code>2 x y</code> 求 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">x</span></span></span></span> 到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.625em;vertical-align:-.19444em"></span><span class="mord mathnormal" style="margin-right:.03588em">y</span></span></span></span> 的路径的权值。</p></li><li><p><code>3 x</code> 在以 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">x</span></span></span></span> 为根的子树中选择一个点，使得这个点到根节点的路径权值最大，求最大权值。</p></li></ul><p>Bob一共会进行 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">m</span></span></span></span> 次操作</p><hr><h3 id="分析-4"><a class="markdownIt-Anchor" href="#分析-4"></a> 分析</h3><p>再补充一道题，<s>应wjy的要求，我把这道题也放在LCT里讲讲，虽然没必要拿LCT</s>。首先按我们看看这道题都有哪些操作，对于第一个操作，我们楞的一看，往 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal">x</span></span></span></span> 到根节点的路径上加一个颜色，我们很容易就能想到 [LCT]{.rainbow} 中的 [access]{.rainbow} 操作，那么一个比较 naive 的想法就是直接修改一下 [access]{.rainbow} 的细节即可。然后我们看第二个操作，求权值，这不好求吗，我们直接看一下这条路径上有多少虚边即可，对于第三个操作我们可以直接求出 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>f</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">dfs</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.8888799999999999em;vertical-align:-.19444em"></span><span class="mord mathnormal">d</span><span class="mord mathnormal" style="margin-right:.10764em">f</span><span class="mord mathnormal">s</span></span></span></span> 序，用线段树维护一下区间最值。</p><p>然后我们看一下我们刚才说的 [access]{.rainbow} 函数应该怎么改，实际上，我们对于这道题我们要求的是虚边的个数，那么我们在 [access]{.rainbow} 的过程中是如果有实边就先将他变成虚边，然后将另一条边建成实边，对于原有的实边，我们造成的贡献就是将他的子树内所有的经过的虚边数量减一，对于新加入的，贡献就自然是加一，然后这道题其实就没啥了。</p><p>下面是代码实现</p><pre class="highlight"><code class="cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span>

<span class="hljs-keyword">namespace</span> read_write
&#123;
    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">read</span><span class="hljs-params">(T &amp;x)</span>
    </span>&#123;
        x = <span class="hljs-number">0</span>;
        T f = <span class="hljs-number">1</span>;
        <span class="hljs-type">char</span> ch = <span class="hljs-built_in">getchar</span>();
        <span class="hljs-keyword">while</span> (ch &gt; <span class="hljs-string">&#x27;9&#x27;</span> || ch &lt; <span class="hljs-string">&#x27;0&#x27;</span>)
        &#123;
            <span class="hljs-keyword">if</span> (ch == <span class="hljs-string">&#x27;-&#x27;</span>)
                f = <span class="hljs-number">-1</span>;
            ch = <span class="hljs-built_in">getchar</span>();
        &#125;
        <span class="hljs-keyword">while</span> (ch &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="hljs-string">&#x27;9&#x27;</span>)
            x = x * <span class="hljs-number">10</span> + ch - <span class="hljs-string">&#x27;0&#x27;</span>, ch = <span class="hljs-built_in">getchar</span>();
        x *= f;
        <span class="hljs-keyword">return</span>;
    &#125;

    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">write</span><span class="hljs-params">(T x)</span>
    </span>&#123;
        <span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">0</span>)
        &#123;
            x = -x;
            <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;-&#x27;</span>);
        &#125;
        <span class="hljs-keyword">if</span> (x &gt; <span class="hljs-number">9</span>)
            <span class="hljs-built_in">write</span>(x / <span class="hljs-number">10</span>);
        <span class="hljs-built_in">putchar</span>(x % <span class="hljs-number">10</span> + <span class="hljs-string">&#x27;0&#x27;</span>);
    &#125;

    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
    <span class="hljs-function">T <span class="hljs-title">max</span><span class="hljs-params">(T x, T y)</span>
    </span>&#123;
        <span class="hljs-keyword">return</span> x &gt; y ? x : y;
    &#125;

    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
    <span class="hljs-function">T <span class="hljs-title">min</span><span class="hljs-params">(T x, T y)</span>
    </span>&#123;
        <span class="hljs-keyword">return</span> x &gt; y ? y : x;
    &#125;

    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(T &amp;a, T &amp;b)</span>
    </span>&#123;
        T tem = b;
        b = a;
        a = tem;
    &#125;
&#125;

<span class="hljs-keyword">namespace</span> Segment
&#123;
    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> read_write;

    <span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e6</span> + <span class="hljs-number">10</span>;

    <span class="hljs-type">int</span> n, m;
    <span class="hljs-type">int</span> dep[N], siz[N], son[N], top[N], id[N];
    <span class="hljs-type">int</span> dfn[N], h[N], fa[N], timestamp, idx;

    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span>
    &#123;
        <span class="hljs-type">int</span> ne, v;
    &#125; e[N];

    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">TREE</span>
    &#123;
        <span class="hljs-type">int</span> l, r;
        <span class="hljs-type">int</span> mx, tag;
    &#125; Tr[N];

    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v)</span>
    </span>&#123;
        e[++ idx].v = v, e[idx].ne = h[u], h[u] = idx;
    &#125;

    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs1</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> fath)</span>
    </span>&#123;
        fa[u] = fath, siz[u] = <span class="hljs-number">1</span>;
        dep[u] = dep[fath] + <span class="hljs-number">1</span>;
        
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = h[u] ; i ; i = e[i].ne)
        &#123;
            <span class="hljs-type">int</span> v = e[i].v;
            <span class="hljs-keyword">if</span>(v == fath)
                <span class="hljs-keyword">continue</span>;
            <span class="hljs-built_in">dfs1</span>(v, u);
            siz[u] += siz[v];
            <span class="hljs-keyword">if</span>(siz[v] &gt; siz[son[u]])
                son[u] = v;
        &#125;
    &#125;

    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs2</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> tp)</span>
    </span>&#123;
        dfn[u] = ++ timestamp;
        top[u] = tp, id[timestamp] = u;
        <span class="hljs-keyword">if</span>(son[u])
            <span class="hljs-built_in">dfs2</span>(son[u], tp);
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = h[u] ; i ; i = e[i].ne)
        &#123;
            <span class="hljs-type">int</span> v = e[i].v;
            <span class="hljs-keyword">if</span>(v == fa[u] || v == son[u])
                <span class="hljs-keyword">continue</span>;
            <span class="hljs-built_in">dfs2</span>(v, v);
        &#125;
    &#125;

    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Pushup</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span>
    </span>&#123;
        Tr[u].mx = <span class="hljs-built_in">max</span>(Tr[u &lt;&lt; <span class="hljs-number">1</span>].mx, Tr[u &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>].mx);
    &#125;    

    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Pushdown</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span>
    </span>&#123;
        <span class="hljs-keyword">if</span>(Tr[u].tag)
        &#123;
            Tr[u &lt;&lt; <span class="hljs-number">1</span>].tag += Tr[u].tag;
            Tr[u &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>].tag += Tr[u].tag;
            
            Tr[u &lt;&lt; <span class="hljs-number">1</span>].mx += Tr[u].tag;
            Tr[u &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>].mx += Tr[u].tag;
            Tr[u].tag = <span class="hljs-number">0</span>;
        &#125;
    &#125;

    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span>
    </span>&#123;
        Tr[u].l = l, Tr[u].r = r;
        <span class="hljs-keyword">if</span>(l == r)
        &#123;
            Tr[u].mx = dep[id[l]];
            <span class="hljs-keyword">return</span>;
        &#125;

        <span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;
        <span class="hljs-built_in">build</span>(u &lt;&lt; <span class="hljs-number">1</span>, l, mid), <span class="hljs-built_in">build</span>(u &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>, mid + <span class="hljs-number">1</span>, r);
        <span class="hljs-built_in">Pushup</span>(u);
    &#125;

    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">modify</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> w)</span>
    </span>&#123;
        <span class="hljs-keyword">if</span>(l &lt;= Tr[u].l &amp;&amp; r &gt;= Tr[u].r)
        &#123;
            Tr[u].tag += w;
            Tr[u].mx += w;
            <span class="hljs-keyword">return</span> ;
        &#125;
        <span class="hljs-built_in">Pushdown</span>(u);
        <span class="hljs-type">int</span> mid = Tr[u].l + Tr[u].r &gt;&gt; <span class="hljs-number">1</span>;
        <span class="hljs-keyword">if</span>(l &lt;= mid)
            <span class="hljs-built_in">modify</span>(u &lt;&lt; <span class="hljs-number">1</span>, l, r, w);
        <span class="hljs-keyword">if</span>(r &gt; mid)
            <span class="hljs-built_in">modify</span>(u &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>, l, r, w);
        <span class="hljs-built_in">Pushup</span>(u);
    &#125;

    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span>
    </span>&#123;
        <span class="hljs-keyword">if</span>(l &lt;= Tr[u].l &amp;&amp; r &gt;= Tr[u].r)
            <span class="hljs-keyword">return</span> Tr[u].mx;
        <span class="hljs-built_in">Pushdown</span>(u);
        <span class="hljs-type">int</span> mid = Tr[u].l + Tr[u].r &gt;&gt; <span class="hljs-number">1</span>;
        <span class="hljs-type">int</span> res = <span class="hljs-number">-1</span>;
        <span class="hljs-keyword">if</span>(l &lt;= mid)
            res = <span class="hljs-built_in">max</span>(res, <span class="hljs-built_in">query</span>(u &lt;&lt; <span class="hljs-number">1</span>, l, r));
        <span class="hljs-keyword">if</span>(r &gt; mid)
            res = <span class="hljs-built_in">max</span>(res, <span class="hljs-built_in">query</span>(u &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>, l, r));
        <span class="hljs-keyword">return</span> res;
    &#125;
    
    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_lca</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v)</span>
    </span>&#123;
        <span class="hljs-keyword">while</span>(top[u] != top[v])
        &#123;
            <span class="hljs-keyword">if</span>(dep[top[u]] &lt; dep[top[v]])
                v = fa[top[v]];
            <span class="hljs-keyword">else</span> 
                u = fa[top[u]];
        &#125;

        <span class="hljs-keyword">return</span> dep[u] &lt; dep[v] ? u : v;
    &#125;
&#125;

<span class="hljs-keyword">namespace</span> LCT
&#123;
    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> Segment;

    <span class="hljs-type">int</span> stk[N];

    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Splay</span>
    &#123;
        <span class="hljs-type">int</span> s[<span class="hljs-number">2</span>], rev;
        <span class="hljs-type">int</span> fa;
    &#125; tr[N];

    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushrev</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span>
    </span>&#123;
        <span class="hljs-built_in">swap</span>(tr[u].s[<span class="hljs-number">0</span>], tr[u].s[<span class="hljs-number">1</span>]);
        tr[u].rev ^= <span class="hljs-number">1</span>;
    &#125;

    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushdown</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span>
    </span>&#123;
        <span class="hljs-keyword">if</span>(tr[u].rev)
        &#123;
            <span class="hljs-built_in">pushrev</span>(tr[u].s[<span class="hljs-number">0</span>]), <span class="hljs-built_in">pushrev</span>(tr[u].s[<span class="hljs-number">1</span>]);
            tr[u].rev = <span class="hljs-number">0</span>;
        &#125;
    &#125;

    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isroot</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span>
    </span>&#123;
        <span class="hljs-keyword">return</span> (tr[tr[x].fa].s[<span class="hljs-number">0</span>] != x &amp;&amp; tr[tr[x].fa].s[<span class="hljs-number">1</span>] != x);
    &#125;

    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">rotate</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span>
    </span>&#123;
        <span class="hljs-type">int</span> y = tr[x].fa, z = tr[y].fa;
        <span class="hljs-type">int</span> k = tr[y].s[<span class="hljs-number">1</span>] == x;
        <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">isroot</span>(y))
            tr[z].s[tr[z].s[<span class="hljs-number">1</span>] == y] = x;
        tr[x].fa = z;
        tr[y].s[k] = tr[x].s[k ^ <span class="hljs-number">1</span>], tr[tr[x].s[k ^ <span class="hljs-number">1</span>]].fa = y;
        tr[x].s[k ^ <span class="hljs-number">1</span>] = y, tr[y].fa = x;
    &#125;

    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">splay</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span>
    </span>&#123;
        <span class="hljs-type">int</span> top = <span class="hljs-number">0</span>, r = x;
        stk[++ top] = r;
        <span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isroot</span>(r))
            stk[++ top] = r = tr[r].fa;
        <span class="hljs-keyword">while</span>(top)
            <span class="hljs-built_in">pushdown</span>(stk[top --]);
        <span class="hljs-keyword">while</span>(!<span class="hljs-built_in">isroot</span>(x))
        &#123;
            <span class="hljs-type">int</span> y = tr[x].fa, z = tr[y].fa;
            <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">isroot</span>(y))
            &#123;
                <span class="hljs-keyword">if</span>((tr[y].s[<span class="hljs-number">1</span>] == x) ^ (tr[z].s[<span class="hljs-number">1</span>] == y))
                    <span class="hljs-built_in">rotate</span>(x);
                <span class="hljs-keyword">else</span> 
                    <span class="hljs-built_in">rotate</span>(y);
            &#125;
            <span class="hljs-built_in">rotate</span>(x);
        &#125;
    &#125;

    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findroot</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span>
    </span>&#123;
        <span class="hljs-keyword">while</span>(tr[x].s[<span class="hljs-number">0</span>])
            x = tr[x].s[<span class="hljs-number">0</span>];
        <span class="hljs-keyword">return</span> x;
    &#125;

    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">access</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span>
    </span>&#123;
        <span class="hljs-type">int</span> z = x;
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> y = <span class="hljs-number">0</span> ; x ; y = x, x = tr[x].fa)
        &#123;
            <span class="hljs-built_in">splay</span>(x);
            <span class="hljs-keyword">if</span>(tr[x].s[<span class="hljs-number">1</span>])
            &#123;
                <span class="hljs-type">int</span> temp = <span class="hljs-built_in">findroot</span>(tr[x].s[<span class="hljs-number">1</span>]);
                <span class="hljs-built_in">modify</span>(<span class="hljs-number">1</span>, dfn[temp], dfn[temp] + siz[temp] - <span class="hljs-number">1</span>, <span class="hljs-number">1</span>);
            &#125;

            <span class="hljs-keyword">if</span>(tr[x].s[<span class="hljs-number">1</span>] = y)
            &#123;
                <span class="hljs-type">int</span> temp = <span class="hljs-built_in">findroot</span>(tr[x].s[<span class="hljs-number">1</span>]);
                <span class="hljs-built_in">modify</span>(<span class="hljs-number">1</span>, dfn[temp], dfn[temp] + siz[temp] - <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>);
            &#125;
        &#125;
        <span class="hljs-built_in">splay</span>(z);
    &#125;
&#125;

<span class="hljs-keyword">namespace</span> Solve
&#123;
    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> LCT;

    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span>
    </span>&#123;
        <span class="hljs-built_in">read</span>(n), <span class="hljs-built_in">read</span>(m);

        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt; n ; ++ i)
        &#123;
            <span class="hljs-type">int</span> u, v;
            <span class="hljs-built_in">read</span>(u), <span class="hljs-built_in">read</span>(v);
            <span class="hljs-built_in">add</span>(u, v), <span class="hljs-built_in">add</span>(v, u);
        &#125;

        <span class="hljs-built_in">dfs1</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>),  <span class="hljs-built_in">dfs2</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>);
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt;= n ; ++ i)   <span class="hljs-comment">//一定要记得初始化 splay 中的每个节点父亲</span>
            tr[i].fa = fa[i];
        <span class="hljs-built_in">build</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n);

        <span class="hljs-keyword">while</span>(m -- )
        &#123;
            <span class="hljs-type">int</span> op, x;
            <span class="hljs-built_in">read</span>(op), <span class="hljs-built_in">read</span>(x);
            <span class="hljs-keyword">if</span>(op == <span class="hljs-number">1</span>)
                <span class="hljs-built_in">access</span>(x);
            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(op == <span class="hljs-number">2</span>)
            &#123;
                <span class="hljs-type">int</span> y, lca, ans;
                <span class="hljs-built_in">read</span>(y);
                lca = <span class="hljs-built_in">get_lca</span>(x, y);
                ans = <span class="hljs-built_in">query</span>(<span class="hljs-number">1</span>, dfn[x], dfn[x]) + <span class="hljs-built_in">query</span>(<span class="hljs-number">1</span>, dfn[y], dfn[y]) - <span class="hljs-number">2</span> * <span class="hljs-built_in">query</span>(<span class="hljs-number">1</span>, dfn[lca], dfn[lca]) + <span class="hljs-number">1</span>;
                <span class="hljs-built_in">write</span>(ans), <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);
            &#125;
            <span class="hljs-keyword">else</span> 
            &#123;
                <span class="hljs-built_in">write</span>(<span class="hljs-built_in">query</span>(<span class="hljs-number">1</span>, dfn[x], dfn[x] + siz[x] - <span class="hljs-number">1</span>));
                <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&quot;</span>);
            &#125;
        &#125;
    &#125;
&#125;

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>&#123;
    Solve :: <span class="hljs-built_in">solve</span>();

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;
</code></pre><h1 id="エピローグrainbow"><a class="markdownIt-Anchor" href="#エピローグrainbow"></a> [エピローグ]{.rainbow}</h1><p>那么到这里常用平衡树和技巧啥的就都结束了，其实平衡树理解了原理之后学起来应该是比较简单的吧 [/kel]{.rainbow} 。剩下的就是练题了。</p><p>+++success 题单</p><ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3RyYWluaW5nLzM2Nzg0MyNwcm9ibGVtcw==">LCT</span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cubHVvZ3UuY29tLmNuL3RyYWluaW5nLzM2ODUyMCNpbmZvcm1hdGlvbg==">平衡树</span><br>+++</li></ul><div class="tags"><a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag"><i class="ic i-tag"></i> 数据结构</a> <a href="/tags/%E7%AC%94%E8%AE%B0/" rel="tag"><i class="ic i-tag"></i> 笔记</a> <a href="/tags/%E5%B9%B3%E8%A1%A1%E6%A0%91/" rel="tag"><i class="ic i-tag"></i> 平衡树</a></div></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2023-08-31 18:13:26" itemprop="dateModified" datetime="2023-08-31T18:13:26+08:00">2023-08-31</time> </span><span id="2023/08/25/Fhq/" class="item leancloud_visitors" data-flag-title="平衡树全家桶" title="阅读次数"><span class="icon"><i class="ic i-eye"></i> </span><span class="text">阅读次数</span> <span class="leancloud-visitors-count"></span> <span class="text">次</span></span></div><div class="reward"><button><i class="ic i-heartbeat"></i> 赞赏</button><p>请我喝[茶]~(￣▽￣)~*</p><div id="qr"><div><img data-src="/images/wechatpay.png" alt="Tokai Teio 微信支付"><p>微信支付</p></div><div><img data-src="/images/alipay.png" alt="Tokai Teio 支付宝"><p>支付宝</p></div><div><img data-src="/images/paypal.png" alt="Tokai Teio 贝宝"><p>贝宝</p></div></div></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>Tokai Teio <i class="ic i-at"><em>@</em></i>桜の風</li><li class="link"><strong>本文链接：</strong> <a href="https://undead-fire-ace.github.io/2023/08/25/Fhq/" title="平衡树全家桶">https://undead-fire-ace.github.io/2023/08/25/Fhq/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/2023/08/23/scan-line/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;gitcode.net&#x2F;Rabilista&#x2F;picture&#x2F;-&#x2F;raw&#x2F;master&#x2F;pic&#x2F;54.jpeg" title="扫描线"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i></span><h3>扫描线</h3></a></div><div class="item right"><a href="/2023/08/25/Segmnet-Tree-Merge/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;gitcode.net&#x2F;Rabilista&#x2F;picture&#x2F;-&#x2F;raw&#x2F;master&#x2F;pic&#x2F;39.jpeg" title="线段树合并笔记"><span class="type">下一篇</span> <span class="category"><i class="ic i-flag"></i></span><h3>线段树合并笔记</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#treap%E6%97%8Frainbow"><span class="toc-number">1.</span> <span class="toc-text">[treap族]{.rainbow}</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%89%E6%97%8Btreap"><span class="toc-number">1.1.</span> <span class="toc-text">有旋treap</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%B4%E6%8A%A4%E5%B9%B3%E8%A1%A1%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-number">1.1.1.</span> <span class="toc-text">维护平衡的方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%8B%E8%BD%AC"><span class="toc-number">1.1.2.</span> <span class="toc-text">旋转</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%92%E5%85%A5"><span class="toc-number">1.1.3.</span> <span class="toc-text">插入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A0%E9%99%A4"><span class="toc-number">1.1.4.</span> <span class="toc-text">删除</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2"><span class="toc-number">1.1.5.</span> <span class="toc-text">查询</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E6%8E%92%E5%90%8D%E6%8C%89%E5%80%BC%E6%9F%A5%E5%BA%8F"><span class="toc-number">1.1.5.1.</span> <span class="toc-text">查询排名（按值查序）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E5%80%BC%E6%8C%89%E5%BA%8F%E6%9F%A5%E5%80%BC"><span class="toc-number">1.1.5.2.</span> <span class="toc-text">查询值（按序查值）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B1%82%E5%89%8D%E9%A9%B1%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%AF%94%E5%AE%83%E5%B0%8F%E7%9A%84%E5%80%BC"><span class="toc-number">1.1.5.3.</span> <span class="toc-text">求前驱（第一个比它小的值）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B1%82%E5%90%8E%E7%BB%A7%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%AF%94%E5%AE%83%E5%A4%A7%E7%9A%84%E5%80%BC"><span class="toc-number">1.1.5.4.</span> <span class="toc-text">求后继（第一个比它大的值）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%A0%E6%97%8Btreap-fhq-treap-rainbow"><span class="toc-number">1.2.</span> <span class="toc-text">[无旋treap (Fhq treap) !!!]{.rainbow}</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%B4%E6%8A%A4%E5%B9%B3%E8%A1%A1%E7%9A%84%E6%96%B9%E5%BC%8F-2"><span class="toc-number">1.2.1.</span> <span class="toc-text">维护平衡的方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E8%A3%82splitrainbow"><span class="toc-number">1.2.2.</span> <span class="toc-text">[分裂(Split)]{.rainbow}</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%89%E7%85%A7%E5%80%BC%E7%9A%84%E5%A4%A7%E5%B0%8F%E8%BF%9B%E8%A1%8C%E5%88%86%E8%A3%82rainbow"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">[按照值的大小进行分裂]{.rainbow}</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%89%E7%85%A7%E5%AD%90%E6%A0%91%E7%9A%84%E5%A4%A7%E5%B0%8F%E8%BF%9B%E8%A1%8C%E5%88%86%E8%A3%82rainbow"><span class="toc-number">1.2.2.2.</span> <span class="toc-text">[按照子树的大小进行分裂]{.rainbow}</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8"><span class="toc-number">1.2.2.3.</span> <span class="toc-text">作用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%88%E5%B9%B6mergerainbow"><span class="toc-number">1.2.3.</span> <span class="toc-text">[合并(merge)]{.rainbow}</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%9F%E8%83%BD"><span class="toc-number">1.2.4.</span> <span class="toc-text">功能</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8F%92%E5%85%A5rainbow"><span class="toc-number">1.2.4.1.</span> <span class="toc-text">[插入]{.rainbow}</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A0%E9%99%A4rainbow"><span class="toc-number">1.2.4.2.</span> <span class="toc-text">[删除]{.rainbow}</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B6%E4%BB%96"><span class="toc-number">1.2.4.3.</span> <span class="toc-text">其他</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9B%BF%E7%BD%AA%E7%BE%8A%E6%A0%91"><span class="toc-number">2.</span> <span class="toc-text">替罪羊树</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8D%E6%9E%84"><span class="toc-number">2.1.</span> <span class="toc-text">重构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8F%92%E5%85%A5-%E5%88%A0%E9%99%A4"><span class="toc-number">2.2.</span> <span class="toc-text">插入 &amp; 删除</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B6%E4%BB%96-2"><span class="toc-number">2.3.</span> <span class="toc-text">其他</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#splay"><span class="toc-number">3.</span> <span class="toc-text">Splay</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#rotate"><span class="toc-number">3.1.</span> <span class="toc-text">Rotate</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#splay-2"><span class="toc-number">3.2.</span> <span class="toc-text">Splay</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8F%92%E5%85%A5-2"><span class="toc-number">3.3.</span> <span class="toc-text">插入</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2-2"><span class="toc-number">3.4.</span> <span class="toc-text">查询</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%89%E5%80%BC%E6%9F%A5%E5%BA%8F"><span class="toc-number">3.4.1.</span> <span class="toc-text">按值查序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%89%E5%BA%8F%E6%9F%A5%E5%80%BC"><span class="toc-number">3.4.2.</span> <span class="toc-text">按序查值</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#lctrainbow"><span class="toc-number">4.</span> <span class="toc-text">[LCT]{.rainbow}</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#accessrainbow"><span class="toc-number">4.1.</span> <span class="toc-text">[access]{.rainbow}</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#makeroot"><span class="toc-number">4.2.</span> <span class="toc-text">makeroot</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#findroot"><span class="toc-number">4.3.</span> <span class="toc-text">findroot</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#split"><span class="toc-number">4.4.</span> <span class="toc-text">split</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#link"><span class="toc-number">4.5.</span> <span class="toc-text">link</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#cut"><span class="toc-number">4.6.</span> <span class="toc-text">cut</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#rotate-splay"><span class="toc-number">4.7.</span> <span class="toc-text">rotate &amp; splay</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%9F%A5%E8%AD%98%E3%83%9D%E3%82%A4%E3%83%B3%E3%83%88%E3%81%AF%E7%B5%82%E3%82%8F%E3%82%8A%E3%81%BE%E3%81%97%E3%81%9Frainbow"><span class="toc-number">5.</span> <span class="toc-text">[知識ポイントは終わりました]{.rainbow}</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98rainbow"><span class="toc-number">6.</span> <span class="toc-text">[例题]{.rainbow}</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#sdoi2008-%E6%B4%9E%E7%A9%B4%E5%8B%98%E6%B5%8B"><span class="toc-number">6.1.</span> <span class="toc-text">SDOI2008 洞穴勘测</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0"><span class="toc-number">6.1.1.</span> <span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E6%9E%90"><span class="toc-number">6.1.2.</span> <span class="toc-text">分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%BD%E5%AE%B6%E9%9B%86%E8%AE%AD%E9%98%9F-tree-ii"><span class="toc-number">6.2.</span> <span class="toc-text">国家集训队 Tree II</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-2"><span class="toc-number">6.2.1.</span> <span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E6%A0%BC%E5%BC%8F"><span class="toc-number">6.2.2.</span> <span class="toc-text">输入格式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%93%E5%87%BA%E6%A0%BC%E5%BC%8F"><span class="toc-number">6.2.3.</span> <span class="toc-text">输出格式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E6%9E%90-2"><span class="toc-number">6.2.4.</span> <span class="toc-text">分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E5%B0%8F%E5%B7%AE%E5%80%BC%E7%94%9F%E6%88%90%E6%A0%91"><span class="toc-number">6.3.</span> <span class="toc-text">最小差值生成树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-3"><span class="toc-number">6.3.1.</span> <span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E6%A0%BC%E5%BC%8F-2"><span class="toc-number">6.3.2.</span> <span class="toc-text">输入格式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%93%E5%87%BA%E6%A0%BC%E5%BC%8F-2"><span class="toc-number">6.3.3.</span> <span class="toc-text">输出格式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E6%9E%90-3"><span class="toc-number">6.3.4.</span> <span class="toc-text">分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#sdoi2017-%E6%A0%91%E7%82%B9%E6%B6%82%E8%89%B2"><span class="toc-number">6.4.</span> <span class="toc-text">SDOI2017 树点涂色</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0-4"><span class="toc-number">6.4.1.</span> <span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E6%9E%90-4"><span class="toc-number">6.4.2.</span> <span class="toc-text">分析</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E3%82%A8%E3%83%94%E3%83%AD%E3%83%BC%E3%82%B0rainbow"><span class="toc-number">7.</span> <span class="toc-text">[エピローグ]{.rainbow}</span></a></li></ol></div><div class="related panel pjax" data-title="系列文章"></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="Tokai Teio" data-src="/images/avatar.jpg"><p class="name" itemprop="name">Tokai Teio</p><div class="description" itemprop="description"></div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">24</span> <span class="name">文章</span></a></div><div class="item tags"><a href="/tags/"><span class="count">21</span> <span class="name">标签</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL1VuZGVhZC1GaXJlLUFjZQ==" title="https:&#x2F;&#x2F;github.com&#x2F;Undead-Fire-Ace"><i class="ic i-github"></i></span> <span class="exturl item music" data-url="aHR0cHM6Ly9tdXNpYy4xNjMuY29tLyMvdXNlci9ob21lP2lkPTg0NjU5MTg4Mjg=" title="https:&#x2F;&#x2F;music.163.com&#x2F;#&#x2F;user&#x2F;home?id&#x3D;8465918828"><i class="ic i-cloud-music"></i></span> <span class="exturl item email" data-url="bWFpbHRvOmx1Y2swNjA3QGhvdG1haWwuY29t" title="mailto:luck0607@hotmail.com"><i class="ic i-envelope"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item"><a href="/about/" rel="section"><i class="ic i-user"></i>关于</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-magic"></i>links</a><ul class="submenu"><li class="item"><a href="/friends/" rel="section"><i class="ic i-heart"></i>friends</a></li></ul></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/2023/08/23/scan-line/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/2023/08/25/Segmnet-Tree-Merge/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"></div><span><a href="/2023/08/21/Fried-neck-dragon/" title="炸脖龙Ⅰ">炸脖龙Ⅰ</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/2023/08/22/magic-forest/" title="NOI2014 魔法森林">NOI2014 魔法森林</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/2023/09/14/memory/" title="夢のような思い出">夢のような思い出</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/2023/08/22/cutlet/" title="CF939F Cutlet 题解">CF939F Cutlet 题解</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/2023/08/22/windows-star/" title="窗口的星星 题解">窗口的星星 题解</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/2023/08/22/shoi-dance/" title="SHOI2009 舞会 题解">SHOI2009 舞会 题解</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/2023/08/25/Segmnet-Tree-Merge/" title="线段树合并笔记">线段树合并笔记</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/2023/08/21/summer-camp/" title="2023暑假集训">2023暑假集训</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/2023/08/21/sort/" title="HEOI2016&#x2F;TJOI2016排序">HEOI2016/TJOI2016排序</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/2023/08/22/scoi-zip/" title="SCOI2007压缩 题解">SCOI2007压缩 题解</a></span></li></ul></div><div><h2>最新评论</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; 2010 – <span itemprop="copyrightYear">2023</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">Tokai Teio @ Yume Shoka</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i> </span><span title="站点总字数">149k 字</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="ic i-coffee"></i> </span><span title="站点阅读时长">2:16</span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"2023/08/25/Fhq/",favicon:{show:"（●´3｀●）やれやれだぜ",hide:"(´Д｀)大変だ！"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script></body></html><!-- rebuild by hrmmi -->